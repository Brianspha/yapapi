{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Golem Python API How to use Rendering from yapapi.runner import Engine , Task , vm from datetime import timedelta async def main (): package = await vm . repo ( image_hash = 'ef007138617985ebb871e4305bc86fc97073f1ea9ab0ade9ad492ea995c4bc8b' ) async def worker ( ctx , tasks ): ctx . send_file ( './scene.blend' , '/golem/resource/scene.blend' ) async for task in tasks : ctx . begin () crops = [{ \"outfilebasename\" : \"out\" , \"borders_x\" : [ 0.0 , 1.0 ], \"borders_y\" : [ 0.0 , 1.0 ] }] ctx . send_json ( '/golem/work/params.json' , { 'scene_file' : '/golem/resource/scene.blend' , 'resolution' : ( 800 , 600 ), 'use_compositing' : False , 'crops' : crops , 'samples' : 100 , 'frames' : [ task . frame ], 'output_format' : 'PNG' , 'RESOURCES_DIR' : \"/golem/resources\" , 'WORK_DIR' : '/golem/work' , 'OUTPUT_DIR' : '/golem/output' }) ctx . run ( '/golem/entrypoints/render_entrypoint.py' ) ctx . download_file ( '/golem/output/out.png' , f 'output_ { task . frame } .png' ) yield ctx . commit () # TODO: Check if job is valid # and reject by: task.reject_task(msg = 'invalid file') task . accept_task () ctx . log ( 'no more frame to render' ) async with Engine ( package = package , max_worker = 10 , budget = 10.0 , timeout = timedelta ( minutes = 5 )) as engine : async for progress in engine . map ( worker , [ Task ( frame = frame ) for frame in range ( 1 , 101 ) ]): print ( \"progress=\" , progress )","title":"Home"},{"location":"#golem-python-api","text":"","title":"Golem Python API"},{"location":"#how-to-use","text":"Rendering from yapapi.runner import Engine , Task , vm from datetime import timedelta async def main (): package = await vm . repo ( image_hash = 'ef007138617985ebb871e4305bc86fc97073f1ea9ab0ade9ad492ea995c4bc8b' ) async def worker ( ctx , tasks ): ctx . send_file ( './scene.blend' , '/golem/resource/scene.blend' ) async for task in tasks : ctx . begin () crops = [{ \"outfilebasename\" : \"out\" , \"borders_x\" : [ 0.0 , 1.0 ], \"borders_y\" : [ 0.0 , 1.0 ] }] ctx . send_json ( '/golem/work/params.json' , { 'scene_file' : '/golem/resource/scene.blend' , 'resolution' : ( 800 , 600 ), 'use_compositing' : False , 'crops' : crops , 'samples' : 100 , 'frames' : [ task . frame ], 'output_format' : 'PNG' , 'RESOURCES_DIR' : \"/golem/resources\" , 'WORK_DIR' : '/golem/work' , 'OUTPUT_DIR' : '/golem/output' }) ctx . run ( '/golem/entrypoints/render_entrypoint.py' ) ctx . download_file ( '/golem/output/out.png' , f 'output_ { task . frame } .png' ) yield ctx . commit () # TODO: Check if job is valid # and reject by: task.reject_task(msg = 'invalid file') task . accept_task () ctx . log ( 'no more frame to render' ) async with Engine ( package = package , max_worker = 10 , budget = 10.0 , timeout = timedelta ( minutes = 5 )) as engine : async for progress in engine . map ( worker , [ Task ( frame = frame ) for frame in range ( 1 , 101 ) ]): print ( \"progress=\" , progress )","title":"How to use"},{"location":"reference/yapapi/","text":"Module yapapi Sub-modules yapapi.props yapapi.rest yapapi.runner yapapi.storage","title":"Index"},{"location":"reference/yapapi/#module-yapapi","text":"","title":"Module yapapi"},{"location":"reference/yapapi/#sub-modules","text":"yapapi.props yapapi.rest yapapi.runner yapapi.storage","title":"Sub-modules"},{"location":"reference/yapapi/props/","text":"Module yapapi.props View Source from .base import Model from dataclasses import dataclass , field from typing import Optional from decimal import Decimal from datetime import datetime @dataclass class Identification ( Model ): name : Optional [ str ] = field ( default = None , metadata = { \"key\" : \"golem.node.id.name\" }) @dataclass () class Activity ( Model ): \"\"\"Activity-related Properties\"\"\" cost_cap : Optional [ Decimal ] = field ( default = None , metadata = { \"key\" : \"golem.activity.cost_cap\" } ) \"\"\"Sets a Hard cap on total cost of the Activity (regardless of the usage vector or pricing function). The Provider is entitled to 'kill' an Activity which exceeds the capped cost amount indicated by Requestor. \"\"\" cost_warning : Optional [ Decimal ] = field ( default = None , metadata = { \"key\" : \"golem.activity.cost_warning\" } ) \"\"\"Sets a Soft cap on total cost of the Activity (regardless of the usage vector or pricing function). When the cost_warning amount is reached for the Activity, the Provider is expected to send a Debit Note to the Requestor, indicating the current amount due \"\"\" timeout_secs : Optional [ float ] = field ( default = None , metadata = { \"key\" : \"golem.activity.timeout_secs\" } ) \"\"\"A timeout value for batch computation (eg. used for container-based batch processes). This property allows to set the timeout to be applied by the Provider when running a batch computation: the Requestor expects the Activity to take no longer than the specified timeout value - which implies that eg. the golem.usage.duration_sec counter shall not exceed the specified timeout value. \"\"\" expiration : Optional [ datetime ] = field ( default = None , metadata = { \"key\" : \"golem.srv.comp.expiration\" } ) \"\"\" \"\"\" ActivityKeys = Activity . keys () Sub-modules yapapi.props.base yapapi.props.com yapapi.props.inf Variables ActivityKeys Classes Activity class Activity ( cost_cap : Union [ decimal . Decimal , NoneType ] = None , cost_warning : Union [ decimal . Decimal , NoneType ] = None , timeout_secs : Union [ float , NoneType ] = None , expiration : Union [ datetime . datetime , NoneType ] = None ) Activity-related Properties View Source class Activity ( Model ) : \"\"\"Activity-related Properties\"\"\" cost_cap : Optional [ Decimal ] = field ( default = None , metadata = { \"key\" : \"golem.activity.cost_cap\" } ) \"\"\"Sets a Hard cap on total cost of the Activity (regardless of the usage vector or pricing function). The Provider is entitled to 'kill' an Activity which exceeds the capped cost amount indicated by Requestor. \"\"\" cost_warning : Optional [ Decimal ] = field ( default = None , metadata = { \"key\" : \"golem.activity.cost_warning\" } ) \"\"\"Sets a Soft cap on total cost of the Activity (regardless of the usage vector or pricing function). When the cost_warning amount is reached for the Activity, the Provider is expected to send a Debit Note to the Requestor, indicating the current amount due \"\"\" timeout_secs : Optional [ float ] = field ( default = None , metadata = { \"key\" : \"golem.activity.timeout_secs\" } ) \"\"\"A timeout value for batch computation (eg. used for container-based batch processes). This property allows to set the timeout to be applied by the Provider when running a batch computation: the Requestor expects the Activity to take no longer than the specified timeout value - which implies that eg. the golem.usage.duration_sec counter shall not exceed the specified timeout value. \"\"\" expiration : Optional [ datetime ] = field ( default = None , metadata = { \"key\" : \"golem.srv.comp.expiration\" } ) \"\"\" \"\"\" Ancestors (in MRO) yapapi.props.base.Model abc.ABC Class variables cost_cap cost_warning expiration timeout_secs Static methods from_props def from_props ( props : Dict [ str , str ] ) -> 'Model' View Source @classmethod def from_props ( cls , props : Props ) -> \"Model\" : field_map = dict ( ( f . metadata [ \"key\" ] , _PyField ( name = f . name , type = f . type , required = f . default is MISSING ), ) for f in fields ( cls ) if \"key\" in f . metadata ) data = dict ( ( field_map [ key ] . encode ( val ) for ( key , val ) in props . items () if key in field_map ) ) cls . _custom_mapping ( props , data ) print ( dict ( data )) self = cls ( ** data ) return self keys def keys ( ) View Source @classmethod def keys ( cls ) : class _Keys : def __init__ ( self , iter ) : self . __dict__ = dict ( iter ) return _Keys (( f . name , f . metadata [ \"key\" ] ) for f in fields ( cls )) Identification class Identification ( name : Union [ str , NoneType ] = None ) Identification(name: Union[str, NoneType] = None) View Source class Identification ( Model ) : name : Optional [ str ] = field ( default = None , metadata = { \"key\" : \"golem.node.id.name\" } ) Ancestors (in MRO) yapapi.props.base.Model abc.ABC Class variables name Static methods from_props def from_props ( props : Dict [ str , str ] ) -> 'Model' View Source @classmethod def from_props ( cls , props : Props ) -> \"Model\" : field_map = dict ( ( f . metadata [ \"key\" ] , _PyField ( name = f . name , type = f . type , required = f . default is MISSING ), ) for f in fields ( cls ) if \"key\" in f . metadata ) data = dict ( ( field_map [ key ] . encode ( val ) for ( key , val ) in props . items () if key in field_map ) ) cls . _custom_mapping ( props , data ) print ( dict ( data )) self = cls ( ** data ) return self keys def keys ( ) View Source @classmethod def keys ( cls ) : class _Keys : def __init__ ( self , iter ) : self . __dict__ = dict ( iter ) return _Keys (( f . name , f . metadata [ \"key\" ] ) for f in fields ( cls ))","title":"Index"},{"location":"reference/yapapi/props/#module-yapapiprops","text":"View Source from .base import Model from dataclasses import dataclass , field from typing import Optional from decimal import Decimal from datetime import datetime @dataclass class Identification ( Model ): name : Optional [ str ] = field ( default = None , metadata = { \"key\" : \"golem.node.id.name\" }) @dataclass () class Activity ( Model ): \"\"\"Activity-related Properties\"\"\" cost_cap : Optional [ Decimal ] = field ( default = None , metadata = { \"key\" : \"golem.activity.cost_cap\" } ) \"\"\"Sets a Hard cap on total cost of the Activity (regardless of the usage vector or pricing function). The Provider is entitled to 'kill' an Activity which exceeds the capped cost amount indicated by Requestor. \"\"\" cost_warning : Optional [ Decimal ] = field ( default = None , metadata = { \"key\" : \"golem.activity.cost_warning\" } ) \"\"\"Sets a Soft cap on total cost of the Activity (regardless of the usage vector or pricing function). When the cost_warning amount is reached for the Activity, the Provider is expected to send a Debit Note to the Requestor, indicating the current amount due \"\"\" timeout_secs : Optional [ float ] = field ( default = None , metadata = { \"key\" : \"golem.activity.timeout_secs\" } ) \"\"\"A timeout value for batch computation (eg. used for container-based batch processes). This property allows to set the timeout to be applied by the Provider when running a batch computation: the Requestor expects the Activity to take no longer than the specified timeout value - which implies that eg. the golem.usage.duration_sec counter shall not exceed the specified timeout value. \"\"\" expiration : Optional [ datetime ] = field ( default = None , metadata = { \"key\" : \"golem.srv.comp.expiration\" } ) \"\"\" \"\"\" ActivityKeys = Activity . keys ()","title":"Module yapapi.props"},{"location":"reference/yapapi/props/#sub-modules","text":"yapapi.props.base yapapi.props.com yapapi.props.inf","title":"Sub-modules"},{"location":"reference/yapapi/props/#variables","text":"ActivityKeys","title":"Variables"},{"location":"reference/yapapi/props/#classes","text":"","title":"Classes"},{"location":"reference/yapapi/props/#activity","text":"class Activity ( cost_cap : Union [ decimal . Decimal , NoneType ] = None , cost_warning : Union [ decimal . Decimal , NoneType ] = None , timeout_secs : Union [ float , NoneType ] = None , expiration : Union [ datetime . datetime , NoneType ] = None ) Activity-related Properties View Source class Activity ( Model ) : \"\"\"Activity-related Properties\"\"\" cost_cap : Optional [ Decimal ] = field ( default = None , metadata = { \"key\" : \"golem.activity.cost_cap\" } ) \"\"\"Sets a Hard cap on total cost of the Activity (regardless of the usage vector or pricing function). The Provider is entitled to 'kill' an Activity which exceeds the capped cost amount indicated by Requestor. \"\"\" cost_warning : Optional [ Decimal ] = field ( default = None , metadata = { \"key\" : \"golem.activity.cost_warning\" } ) \"\"\"Sets a Soft cap on total cost of the Activity (regardless of the usage vector or pricing function). When the cost_warning amount is reached for the Activity, the Provider is expected to send a Debit Note to the Requestor, indicating the current amount due \"\"\" timeout_secs : Optional [ float ] = field ( default = None , metadata = { \"key\" : \"golem.activity.timeout_secs\" } ) \"\"\"A timeout value for batch computation (eg. used for container-based batch processes). This property allows to set the timeout to be applied by the Provider when running a batch computation: the Requestor expects the Activity to take no longer than the specified timeout value - which implies that eg. the golem.usage.duration_sec counter shall not exceed the specified timeout value. \"\"\" expiration : Optional [ datetime ] = field ( default = None , metadata = { \"key\" : \"golem.srv.comp.expiration\" } ) \"\"\" \"\"\"","title":"Activity"},{"location":"reference/yapapi/props/#ancestors-in-mro","text":"yapapi.props.base.Model abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/yapapi/props/#class-variables","text":"cost_cap cost_warning expiration timeout_secs","title":"Class variables"},{"location":"reference/yapapi/props/#static-methods","text":"","title":"Static methods"},{"location":"reference/yapapi/props/#from_props","text":"def from_props ( props : Dict [ str , str ] ) -> 'Model' View Source @classmethod def from_props ( cls , props : Props ) -> \"Model\" : field_map = dict ( ( f . metadata [ \"key\" ] , _PyField ( name = f . name , type = f . type , required = f . default is MISSING ), ) for f in fields ( cls ) if \"key\" in f . metadata ) data = dict ( ( field_map [ key ] . encode ( val ) for ( key , val ) in props . items () if key in field_map ) ) cls . _custom_mapping ( props , data ) print ( dict ( data )) self = cls ( ** data ) return self","title":"from_props"},{"location":"reference/yapapi/props/#keys","text":"def keys ( ) View Source @classmethod def keys ( cls ) : class _Keys : def __init__ ( self , iter ) : self . __dict__ = dict ( iter ) return _Keys (( f . name , f . metadata [ \"key\" ] ) for f in fields ( cls ))","title":"keys"},{"location":"reference/yapapi/props/#identification","text":"class Identification ( name : Union [ str , NoneType ] = None ) Identification(name: Union[str, NoneType] = None) View Source class Identification ( Model ) : name : Optional [ str ] = field ( default = None , metadata = { \"key\" : \"golem.node.id.name\" } )","title":"Identification"},{"location":"reference/yapapi/props/#ancestors-in-mro_1","text":"yapapi.props.base.Model abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/yapapi/props/#class-variables_1","text":"name","title":"Class variables"},{"location":"reference/yapapi/props/#static-methods_1","text":"","title":"Static methods"},{"location":"reference/yapapi/props/#from_props_1","text":"def from_props ( props : Dict [ str , str ] ) -> 'Model' View Source @classmethod def from_props ( cls , props : Props ) -> \"Model\" : field_map = dict ( ( f . metadata [ \"key\" ] , _PyField ( name = f . name , type = f . type , required = f . default is MISSING ), ) for f in fields ( cls ) if \"key\" in f . metadata ) data = dict ( ( field_map [ key ] . encode ( val ) for ( key , val ) in props . items () if key in field_map ) ) cls . _custom_mapping ( props , data ) print ( dict ( data )) self = cls ( ** data ) return self","title":"from_props"},{"location":"reference/yapapi/props/#keys_1","text":"def keys ( ) View Source @classmethod def keys ( cls ) : class _Keys : def __init__ ( self , iter ) : self . __dict__ = dict ( iter ) return _Keys (( f . name , f . metadata [ \"key\" ] ) for f in fields ( cls ))","title":"keys"},{"location":"reference/yapapi/props/base/","text":"Module yapapi.props.base View Source from typing import Dict , Type , Any , Union , List , cast import abc , enum , json from dataclasses import dataclass , fields , MISSING Props = Dict [ str , str ] def as_list ( data : Union [ str , List [ str ]]) -> List [ str ]: if not isinstance ( data , str ): return list ( data ) item = json . loads ( data ) if isinstance ( item , list ): return cast ( List [ str ], item ) return [ str ( item )] def _find_enum ( enum_type : Type [ enum . Enum ], val : str ) -> Any : for member in enum_type . __members__ . values (): if member . value == val : return member return None @dataclass ( frozen = True ) class _PyField : name : str type : type required : bool def encode ( self , value : str ): if issubclass ( self . type , enum . Enum ): return self . name , self . type ( value ) return self . name , value class Model ( abc . ABC ): def __init__ ( self , ** kwargs ): pass @classmethod def _custom_mapping ( cls , props : Props , data : Dict [ str , Any ]): pass @classmethod def from_props ( cls , props : Props ) -> \"Model\" : field_map = dict ( ( f . metadata [ \"key\" ], _PyField ( name = f . name , type = f . type , required = f . default is MISSING ), ) for f in fields ( cls ) if \"key\" in f . metadata ) data = dict ( ( field_map [ key ] . encode ( val ) for ( key , val ) in props . items () if key in field_map ) ) cls . _custom_mapping ( props , data ) print ( dict ( data )) self = cls ( ** data ) return self @classmethod def keys ( cls ): class _Keys : def __init__ ( self , iter ): self . __dict__ = dict ( iter ) return _Keys (( f . name , f . metadata [ \"key\" ]) for f in fields ( cls )) __all__ = ( \"Model\" , \"as_list\" , \"Props\" ) Variables Props Functions as_list def as_list ( data : Union [ str , List [ str ]] ) -> List [ str ] View Source def as_list ( data : Union [ str, List[str ] ] ) -> List [ str ] : if not isinstance ( data , str ) : return list ( data ) item = json . loads ( data ) if isinstance ( item , list ) : return cast ( List [ str ] , item ) return [ str(item) ] Classes Model class Model ( ** kwargs ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Model ( abc . ABC ) : def __init__ ( self , ** kwargs ) : pass @classmethod def _custom_mapping ( cls , props : Props , data : Dict [ str, Any ] ) : pass @classmethod def from_props ( cls , props : Props ) -> \"Model\" : field_map = dict ( ( f . metadata [ \"key\" ] , _PyField ( name = f . name , type = f . type , required = f . default is MISSING ), ) for f in fields ( cls ) if \"key\" in f . metadata ) data = dict ( ( field_map [ key ] . encode ( val ) for ( key , val ) in props . items () if key in field_map ) ) cls . _custom_mapping ( props , data ) print ( dict ( data )) self = cls ( ** data ) return self @classmethod def keys ( cls ) : class _Keys : def __init__ ( self , iter ) : self . __dict__ = dict ( iter ) return _Keys (( f . name , f . metadata [ \"key\" ] ) for f in fields ( cls )) Ancestors (in MRO) abc.ABC Descendants yapapi.props.Identification yapapi.props.Activity yapapi.props.com.Com yapapi.props.inf.InfBase yapapi.props.inf.InfVm Static methods from_props def from_props ( props : Dict [ str , str ] ) -> 'Model' View Source @classmethod def from_props ( cls , props : Props ) -> \"Model\" : field_map = dict ( ( f . metadata [ \"key\" ] , _PyField ( name = f . name , type = f . type , required = f . default is MISSING ), ) for f in fields ( cls ) if \"key\" in f . metadata ) data = dict ( ( field_map [ key ] . encode ( val ) for ( key , val ) in props . items () if key in field_map ) ) cls . _custom_mapping ( props , data ) print ( dict ( data )) self = cls ( ** data ) return self keys def keys ( ) View Source @classmethod def keys ( cls ) : class _Keys : def __init__ ( self , iter ) : self . __dict__ = dict ( iter ) return _Keys (( f . name , f . metadata [ \"key\" ] ) for f in fields ( cls ))","title":"Base"},{"location":"reference/yapapi/props/base/#module-yapapipropsbase","text":"View Source from typing import Dict , Type , Any , Union , List , cast import abc , enum , json from dataclasses import dataclass , fields , MISSING Props = Dict [ str , str ] def as_list ( data : Union [ str , List [ str ]]) -> List [ str ]: if not isinstance ( data , str ): return list ( data ) item = json . loads ( data ) if isinstance ( item , list ): return cast ( List [ str ], item ) return [ str ( item )] def _find_enum ( enum_type : Type [ enum . Enum ], val : str ) -> Any : for member in enum_type . __members__ . values (): if member . value == val : return member return None @dataclass ( frozen = True ) class _PyField : name : str type : type required : bool def encode ( self , value : str ): if issubclass ( self . type , enum . Enum ): return self . name , self . type ( value ) return self . name , value class Model ( abc . ABC ): def __init__ ( self , ** kwargs ): pass @classmethod def _custom_mapping ( cls , props : Props , data : Dict [ str , Any ]): pass @classmethod def from_props ( cls , props : Props ) -> \"Model\" : field_map = dict ( ( f . metadata [ \"key\" ], _PyField ( name = f . name , type = f . type , required = f . default is MISSING ), ) for f in fields ( cls ) if \"key\" in f . metadata ) data = dict ( ( field_map [ key ] . encode ( val ) for ( key , val ) in props . items () if key in field_map ) ) cls . _custom_mapping ( props , data ) print ( dict ( data )) self = cls ( ** data ) return self @classmethod def keys ( cls ): class _Keys : def __init__ ( self , iter ): self . __dict__ = dict ( iter ) return _Keys (( f . name , f . metadata [ \"key\" ]) for f in fields ( cls )) __all__ = ( \"Model\" , \"as_list\" , \"Props\" )","title":"Module yapapi.props.base"},{"location":"reference/yapapi/props/base/#variables","text":"Props","title":"Variables"},{"location":"reference/yapapi/props/base/#functions","text":"","title":"Functions"},{"location":"reference/yapapi/props/base/#as_list","text":"def as_list ( data : Union [ str , List [ str ]] ) -> List [ str ] View Source def as_list ( data : Union [ str, List[str ] ] ) -> List [ str ] : if not isinstance ( data , str ) : return list ( data ) item = json . loads ( data ) if isinstance ( item , list ) : return cast ( List [ str ] , item ) return [ str(item) ]","title":"as_list"},{"location":"reference/yapapi/props/base/#classes","text":"","title":"Classes"},{"location":"reference/yapapi/props/base/#model","text":"class Model ( ** kwargs ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Model ( abc . ABC ) : def __init__ ( self , ** kwargs ) : pass @classmethod def _custom_mapping ( cls , props : Props , data : Dict [ str, Any ] ) : pass @classmethod def from_props ( cls , props : Props ) -> \"Model\" : field_map = dict ( ( f . metadata [ \"key\" ] , _PyField ( name = f . name , type = f . type , required = f . default is MISSING ), ) for f in fields ( cls ) if \"key\" in f . metadata ) data = dict ( ( field_map [ key ] . encode ( val ) for ( key , val ) in props . items () if key in field_map ) ) cls . _custom_mapping ( props , data ) print ( dict ( data )) self = cls ( ** data ) return self @classmethod def keys ( cls ) : class _Keys : def __init__ ( self , iter ) : self . __dict__ = dict ( iter ) return _Keys (( f . name , f . metadata [ \"key\" ] ) for f in fields ( cls ))","title":"Model"},{"location":"reference/yapapi/props/base/#ancestors-in-mro","text":"abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/yapapi/props/base/#descendants","text":"yapapi.props.Identification yapapi.props.Activity yapapi.props.com.Com yapapi.props.inf.InfBase yapapi.props.inf.InfVm","title":"Descendants"},{"location":"reference/yapapi/props/base/#static-methods","text":"","title":"Static methods"},{"location":"reference/yapapi/props/base/#from_props","text":"def from_props ( props : Dict [ str , str ] ) -> 'Model' View Source @classmethod def from_props ( cls , props : Props ) -> \"Model\" : field_map = dict ( ( f . metadata [ \"key\" ] , _PyField ( name = f . name , type = f . type , required = f . default is MISSING ), ) for f in fields ( cls ) if \"key\" in f . metadata ) data = dict ( ( field_map [ key ] . encode ( val ) for ( key , val ) in props . items () if key in field_map ) ) cls . _custom_mapping ( props , data ) print ( dict ( data )) self = cls ( ** data ) return self","title":"from_props"},{"location":"reference/yapapi/props/base/#keys","text":"def keys ( ) View Source @classmethod def keys ( cls ) : class _Keys : def __init__ ( self , iter ) : self . __dict__ = dict ( iter ) return _Keys (( f . name , f . metadata [ \"key\" ] ) for f in fields ( cls ))","title":"keys"},{"location":"reference/yapapi/props/com/","text":"Module yapapi.props.com View Source from typing import Dict , Any from decimal import Decimal import enum from dataclasses import dataclass , field , Field from .base import Model , Props , as_list SCHEME : str = \"golem.com.scheme\" PRICE_MODEL : str = \"golem.com.pricing.model\" LINEAR_COEFFS : str = \"golem.com.pricing.model.linear.coeffs\" DEFINED_USAGES : str = \"golem.com.usage.vector\" class BillingScheme ( enum . Enum ): PAYU = \"payu\" class PriceModel ( enum . Enum ): LINEAR = \"linear\" class Counter ( enum . Enum ): TIME = \"golem.usage.duration_sec\" CPU = \"golem.usage.cpu_sec\" STORAGE = \"golem.usage.storage_gib\" MAXMEM = \"golem.usage.gib\" UNKNOWN = \"\" @dataclass ( frozen = True ) class Com ( Model ): scheme : BillingScheme = field ( metadata = { \"key\" : SCHEME }) price_model : PriceModel = field ( metadata = { \"key\" : PRICE_MODEL }) @dataclass ( frozen = True ) class ComLinear ( Com ): fixed_price : float price_for : Dict [ Counter , float ] @classmethod def _custom_mapping ( cls , props : Props , data : Dict [ str , Any ]): assert data [ \"price_model\" ] == PriceModel . LINEAR , \"expected linear pricing model\" coeffs = as_list ( props [ LINEAR_COEFFS ]) usages = as_list ( props [ DEFINED_USAGES ]) fixed_price = float ( coeffs . pop ()) price_for = (( Counter ( usages [ i ]), float ( coeffs [ i ])) for i in range ( len ( coeffs ))) data . update ( fixed_price = fixed_price , price_for = dict ( price_for )) Variables DEFINED_USAGES LINEAR_COEFFS PRICE_MODEL SCHEME Classes BillingScheme class BillingScheme ( / , * args , ** kwargs ) An enumeration. View Source class BillingScheme ( enum . Enum ): PAYU = \"payu\" Ancestors (in MRO) enum.Enum Class variables PAYU name value Com class Com ( scheme : yapapi . props . com . BillingScheme , price_model : yapapi . props . com . PriceModel ) Com(scheme: yapapi.props.com.BillingScheme, price_model: yapapi.props.com.PriceModel) View Source class Com ( Model ): scheme: BillingScheme = field ( metadata ={ \"key\" : SCHEME }) price_model: PriceModel = field ( metadata ={ \"key\" : PRICE_MODEL }) Ancestors (in MRO) yapapi.props.base.Model abc.ABC Descendants yapapi.props.com.ComLinear Static methods from_props def from_props ( props : Dict [ str , str ] ) -> 'Model' View Source @classmethod def from_props ( cls , props : Props ) -> \"Model\" : field_map = dict ( ( f . metadata [ \"key\" ] , _PyField ( name = f . name , type = f . type , required = f . default is MISSING ), ) for f in fields ( cls ) if \"key\" in f . metadata ) data = dict ( ( field_map [ key ] . encode ( val ) for ( key , val ) in props . items () if key in field_map ) ) cls . _custom_mapping ( props , data ) print ( dict ( data )) self = cls ( ** data ) return self keys def keys ( ) View Source @classmethod def keys ( cls ) : class _Keys : def __init__ ( self , iter ) : self . __dict__ = dict ( iter ) return _Keys (( f . name , f . metadata [ \"key\" ] ) for f in fields ( cls )) ComLinear class ComLinear ( scheme : yapapi . props . com . BillingScheme , price_model : yapapi . props . com . PriceModel , fixed_price : float , price_for : Dict [ yapapi . props . com . Counter , float ] ) ComLinear(scheme: yapapi.props.com.BillingScheme, price_model: yapapi.props.com.PriceModel, fixed_price: float, price_for: Dict[yapapi.props.com.Counter, float]) View Source class ComLinear ( Com ) : fixed_price : float price_for : Dict [ Counter, float ] @classmethod def _custom_mapping ( cls , props : Props , data : Dict [ str, Any ] ) : assert data [ \"price_model\" ] == PriceModel . LINEAR , \"expected linear pricing model\" coeffs = as_list ( props [ LINEAR_COEFFS ] ) usages = as_list ( props [ DEFINED_USAGES ] ) fixed_price = float ( coeffs . pop ()) price_for = (( Counter ( usages [ i ] ), float ( coeffs [ i ] )) for i in range ( len ( coeffs ))) data . update ( fixed_price = fixed_price , price_for = dict ( price_for )) Ancestors (in MRO) yapapi.props.com.Com yapapi.props.base.Model abc.ABC Static methods from_props def from_props ( props : Dict [ str , str ] ) -> 'Model' View Source @classmethod def from_props ( cls , props : Props ) -> \"Model\" : field_map = dict ( ( f . metadata [ \"key\" ] , _PyField ( name = f . name , type = f . type , required = f . default is MISSING ), ) for f in fields ( cls ) if \"key\" in f . metadata ) data = dict ( ( field_map [ key ] . encode ( val ) for ( key , val ) in props . items () if key in field_map ) ) cls . _custom_mapping ( props , data ) print ( dict ( data )) self = cls ( ** data ) return self keys def keys ( ) View Source @classmethod def keys ( cls ) : class _Keys : def __init__ ( self , iter ) : self . __dict__ = dict ( iter ) return _Keys (( f . name , f . metadata [ \"key\" ] ) for f in fields ( cls )) Counter class Counter ( / , * args , ** kwargs ) An enumeration. View Source class Counter ( enum . Enum ): TIME = \"golem.usage.duration_sec\" CPU = \"golem.usage.cpu_sec\" STORAGE = \"golem.usage.storage_gib\" MAXMEM = \"golem.usage.gib\" UNKNOWN = \"\" Ancestors (in MRO) enum.Enum Class variables CPU MAXMEM STORAGE TIME UNKNOWN name value PriceModel class PriceModel ( / , * args , ** kwargs ) An enumeration. View Source class PriceModel ( enum . Enum ): LINEAR = \"linear\" Ancestors (in MRO) enum.Enum Class variables LINEAR name value","title":"Com"},{"location":"reference/yapapi/props/com/#module-yapapipropscom","text":"View Source from typing import Dict , Any from decimal import Decimal import enum from dataclasses import dataclass , field , Field from .base import Model , Props , as_list SCHEME : str = \"golem.com.scheme\" PRICE_MODEL : str = \"golem.com.pricing.model\" LINEAR_COEFFS : str = \"golem.com.pricing.model.linear.coeffs\" DEFINED_USAGES : str = \"golem.com.usage.vector\" class BillingScheme ( enum . Enum ): PAYU = \"payu\" class PriceModel ( enum . Enum ): LINEAR = \"linear\" class Counter ( enum . Enum ): TIME = \"golem.usage.duration_sec\" CPU = \"golem.usage.cpu_sec\" STORAGE = \"golem.usage.storage_gib\" MAXMEM = \"golem.usage.gib\" UNKNOWN = \"\" @dataclass ( frozen = True ) class Com ( Model ): scheme : BillingScheme = field ( metadata = { \"key\" : SCHEME }) price_model : PriceModel = field ( metadata = { \"key\" : PRICE_MODEL }) @dataclass ( frozen = True ) class ComLinear ( Com ): fixed_price : float price_for : Dict [ Counter , float ] @classmethod def _custom_mapping ( cls , props : Props , data : Dict [ str , Any ]): assert data [ \"price_model\" ] == PriceModel . LINEAR , \"expected linear pricing model\" coeffs = as_list ( props [ LINEAR_COEFFS ]) usages = as_list ( props [ DEFINED_USAGES ]) fixed_price = float ( coeffs . pop ()) price_for = (( Counter ( usages [ i ]), float ( coeffs [ i ])) for i in range ( len ( coeffs ))) data . update ( fixed_price = fixed_price , price_for = dict ( price_for ))","title":"Module yapapi.props.com"},{"location":"reference/yapapi/props/com/#variables","text":"DEFINED_USAGES LINEAR_COEFFS PRICE_MODEL SCHEME","title":"Variables"},{"location":"reference/yapapi/props/com/#classes","text":"","title":"Classes"},{"location":"reference/yapapi/props/com/#billingscheme","text":"class BillingScheme ( / , * args , ** kwargs ) An enumeration. View Source class BillingScheme ( enum . Enum ): PAYU = \"payu\"","title":"BillingScheme"},{"location":"reference/yapapi/props/com/#ancestors-in-mro","text":"enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/yapapi/props/com/#class-variables","text":"PAYU name value","title":"Class variables"},{"location":"reference/yapapi/props/com/#com","text":"class Com ( scheme : yapapi . props . com . BillingScheme , price_model : yapapi . props . com . PriceModel ) Com(scheme: yapapi.props.com.BillingScheme, price_model: yapapi.props.com.PriceModel) View Source class Com ( Model ): scheme: BillingScheme = field ( metadata ={ \"key\" : SCHEME }) price_model: PriceModel = field ( metadata ={ \"key\" : PRICE_MODEL })","title":"Com"},{"location":"reference/yapapi/props/com/#ancestors-in-mro_1","text":"yapapi.props.base.Model abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/yapapi/props/com/#descendants","text":"yapapi.props.com.ComLinear","title":"Descendants"},{"location":"reference/yapapi/props/com/#static-methods","text":"","title":"Static methods"},{"location":"reference/yapapi/props/com/#from_props","text":"def from_props ( props : Dict [ str , str ] ) -> 'Model' View Source @classmethod def from_props ( cls , props : Props ) -> \"Model\" : field_map = dict ( ( f . metadata [ \"key\" ] , _PyField ( name = f . name , type = f . type , required = f . default is MISSING ), ) for f in fields ( cls ) if \"key\" in f . metadata ) data = dict ( ( field_map [ key ] . encode ( val ) for ( key , val ) in props . items () if key in field_map ) ) cls . _custom_mapping ( props , data ) print ( dict ( data )) self = cls ( ** data ) return self","title":"from_props"},{"location":"reference/yapapi/props/com/#keys","text":"def keys ( ) View Source @classmethod def keys ( cls ) : class _Keys : def __init__ ( self , iter ) : self . __dict__ = dict ( iter ) return _Keys (( f . name , f . metadata [ \"key\" ] ) for f in fields ( cls ))","title":"keys"},{"location":"reference/yapapi/props/com/#comlinear","text":"class ComLinear ( scheme : yapapi . props . com . BillingScheme , price_model : yapapi . props . com . PriceModel , fixed_price : float , price_for : Dict [ yapapi . props . com . Counter , float ] ) ComLinear(scheme: yapapi.props.com.BillingScheme, price_model: yapapi.props.com.PriceModel, fixed_price: float, price_for: Dict[yapapi.props.com.Counter, float]) View Source class ComLinear ( Com ) : fixed_price : float price_for : Dict [ Counter, float ] @classmethod def _custom_mapping ( cls , props : Props , data : Dict [ str, Any ] ) : assert data [ \"price_model\" ] == PriceModel . LINEAR , \"expected linear pricing model\" coeffs = as_list ( props [ LINEAR_COEFFS ] ) usages = as_list ( props [ DEFINED_USAGES ] ) fixed_price = float ( coeffs . pop ()) price_for = (( Counter ( usages [ i ] ), float ( coeffs [ i ] )) for i in range ( len ( coeffs ))) data . update ( fixed_price = fixed_price , price_for = dict ( price_for ))","title":"ComLinear"},{"location":"reference/yapapi/props/com/#ancestors-in-mro_2","text":"yapapi.props.com.Com yapapi.props.base.Model abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/yapapi/props/com/#static-methods_1","text":"","title":"Static methods"},{"location":"reference/yapapi/props/com/#from_props_1","text":"def from_props ( props : Dict [ str , str ] ) -> 'Model' View Source @classmethod def from_props ( cls , props : Props ) -> \"Model\" : field_map = dict ( ( f . metadata [ \"key\" ] , _PyField ( name = f . name , type = f . type , required = f . default is MISSING ), ) for f in fields ( cls ) if \"key\" in f . metadata ) data = dict ( ( field_map [ key ] . encode ( val ) for ( key , val ) in props . items () if key in field_map ) ) cls . _custom_mapping ( props , data ) print ( dict ( data )) self = cls ( ** data ) return self","title":"from_props"},{"location":"reference/yapapi/props/com/#keys_1","text":"def keys ( ) View Source @classmethod def keys ( cls ) : class _Keys : def __init__ ( self , iter ) : self . __dict__ = dict ( iter ) return _Keys (( f . name , f . metadata [ \"key\" ] ) for f in fields ( cls ))","title":"keys"},{"location":"reference/yapapi/props/com/#counter","text":"class Counter ( / , * args , ** kwargs ) An enumeration. View Source class Counter ( enum . Enum ): TIME = \"golem.usage.duration_sec\" CPU = \"golem.usage.cpu_sec\" STORAGE = \"golem.usage.storage_gib\" MAXMEM = \"golem.usage.gib\" UNKNOWN = \"\"","title":"Counter"},{"location":"reference/yapapi/props/com/#ancestors-in-mro_3","text":"enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/yapapi/props/com/#class-variables_1","text":"CPU MAXMEM STORAGE TIME UNKNOWN name value","title":"Class variables"},{"location":"reference/yapapi/props/com/#pricemodel","text":"class PriceModel ( / , * args , ** kwargs ) An enumeration. View Source class PriceModel ( enum . Enum ): LINEAR = \"linear\"","title":"PriceModel"},{"location":"reference/yapapi/props/com/#ancestors-in-mro_4","text":"enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/yapapi/props/com/#class-variables_2","text":"LINEAR name value","title":"Class variables"},{"location":"reference/yapapi/props/inf/","text":"Module yapapi.props.inf Infrastructural Properties View Source \"\"\" Infrastructural Properties \"\"\" from typing import Optional , List from dataclasses import dataclass , field from .base import Model INF_MEM : str = \"golem.inf.mem.gib\" INF_STORAGE : str = \"golem.inf.storage.gib\" INF_CORES : str = \"golem.inf.cpu.cores\" TRANSFER_CAPS : str = \"golem.activity.caps.transfer.protocol\" @dataclass class InfBase ( Model ): mem : float = field ( metadata = { \"key\" : INF_MEM }) runtime : str = field ( metadata = { \"key\" : \"golem.runtime.name\" }) storage : Optional [ float ] = field ( default = None , metadata = { \"key\" : INF_STORAGE }) transfers : Optional [ List [ str ]] = field ( default = None , metadata = { \"key\" : TRANSFER_CAPS } ) @dataclass class InfVm ( Model ): cores : int = field ( metadata = { \"key\" : INF_CORES }) Variables INF_CORES INF_MEM INF_STORAGE TRANSFER_CAPS Classes InfBase class InfBase ( mem : float , runtime : str , storage : Union [ float , NoneType ] = None , transfers : Union [ List [ str ], NoneType ] = None ) InfBase(mem: float, runtime: str, storage: Union[float, NoneType] = None, transfers: Union[List[str], NoneType] = None) View Source class InfBase ( Model ) : mem : float = field ( metadata = { \"key\" : INF_MEM } ) runtime : str = field ( metadata = { \"key\" : \"golem.runtime.name\" } ) storage : Optional [ float ] = field ( default = None , metadata = { \"key\" : INF_STORAGE } ) transfers : Optional [ List[str ] ] = field ( default = None , metadata = { \"key\" : TRANSFER_CAPS } ) Ancestors (in MRO) yapapi.props.base.Model abc.ABC Class variables storage transfers Static methods from_props def from_props ( props : Dict [ str , str ] ) -> 'Model' View Source @classmethod def from_props ( cls , props : Props ) -> \"Model\" : field_map = dict ( ( f . metadata [ \"key\" ] , _PyField ( name = f . name , type = f . type , required = f . default is MISSING ), ) for f in fields ( cls ) if \"key\" in f . metadata ) data = dict ( ( field_map [ key ] . encode ( val ) for ( key , val ) in props . items () if key in field_map ) ) cls . _custom_mapping ( props , data ) print ( dict ( data )) self = cls ( ** data ) return self keys def keys ( ) View Source @classmethod def keys ( cls ) : class _Keys : def __init__ ( self , iter ) : self . __dict__ = dict ( iter ) return _Keys (( f . name , f . metadata [ \"key\" ] ) for f in fields ( cls )) InfVm class InfVm ( cores : int ) InfVm(cores: int) View Source class InfVm ( Model ): cores: int = field ( metadata ={ \"key\" : INF_CORES }) Ancestors (in MRO) yapapi.props.base.Model abc.ABC Static methods from_props def from_props ( props : Dict [ str , str ] ) -> 'Model' View Source @classmethod def from_props ( cls , props : Props ) -> \"Model\" : field_map = dict ( ( f . metadata [ \"key\" ] , _PyField ( name = f . name , type = f . type , required = f . default is MISSING ), ) for f in fields ( cls ) if \"key\" in f . metadata ) data = dict ( ( field_map [ key ] . encode ( val ) for ( key , val ) in props . items () if key in field_map ) ) cls . _custom_mapping ( props , data ) print ( dict ( data )) self = cls ( ** data ) return self keys def keys ( ) View Source @classmethod def keys ( cls ) : class _Keys : def __init__ ( self , iter ) : self . __dict__ = dict ( iter ) return _Keys (( f . name , f . metadata [ \"key\" ] ) for f in fields ( cls ))","title":"Inf"},{"location":"reference/yapapi/props/inf/#module-yapapipropsinf","text":"Infrastructural Properties View Source \"\"\" Infrastructural Properties \"\"\" from typing import Optional , List from dataclasses import dataclass , field from .base import Model INF_MEM : str = \"golem.inf.mem.gib\" INF_STORAGE : str = \"golem.inf.storage.gib\" INF_CORES : str = \"golem.inf.cpu.cores\" TRANSFER_CAPS : str = \"golem.activity.caps.transfer.protocol\" @dataclass class InfBase ( Model ): mem : float = field ( metadata = { \"key\" : INF_MEM }) runtime : str = field ( metadata = { \"key\" : \"golem.runtime.name\" }) storage : Optional [ float ] = field ( default = None , metadata = { \"key\" : INF_STORAGE }) transfers : Optional [ List [ str ]] = field ( default = None , metadata = { \"key\" : TRANSFER_CAPS } ) @dataclass class InfVm ( Model ): cores : int = field ( metadata = { \"key\" : INF_CORES })","title":"Module yapapi.props.inf"},{"location":"reference/yapapi/props/inf/#variables","text":"INF_CORES INF_MEM INF_STORAGE TRANSFER_CAPS","title":"Variables"},{"location":"reference/yapapi/props/inf/#classes","text":"","title":"Classes"},{"location":"reference/yapapi/props/inf/#infbase","text":"class InfBase ( mem : float , runtime : str , storage : Union [ float , NoneType ] = None , transfers : Union [ List [ str ], NoneType ] = None ) InfBase(mem: float, runtime: str, storage: Union[float, NoneType] = None, transfers: Union[List[str], NoneType] = None) View Source class InfBase ( Model ) : mem : float = field ( metadata = { \"key\" : INF_MEM } ) runtime : str = field ( metadata = { \"key\" : \"golem.runtime.name\" } ) storage : Optional [ float ] = field ( default = None , metadata = { \"key\" : INF_STORAGE } ) transfers : Optional [ List[str ] ] = field ( default = None , metadata = { \"key\" : TRANSFER_CAPS } )","title":"InfBase"},{"location":"reference/yapapi/props/inf/#ancestors-in-mro","text":"yapapi.props.base.Model abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/yapapi/props/inf/#class-variables","text":"storage transfers","title":"Class variables"},{"location":"reference/yapapi/props/inf/#static-methods","text":"","title":"Static methods"},{"location":"reference/yapapi/props/inf/#from_props","text":"def from_props ( props : Dict [ str , str ] ) -> 'Model' View Source @classmethod def from_props ( cls , props : Props ) -> \"Model\" : field_map = dict ( ( f . metadata [ \"key\" ] , _PyField ( name = f . name , type = f . type , required = f . default is MISSING ), ) for f in fields ( cls ) if \"key\" in f . metadata ) data = dict ( ( field_map [ key ] . encode ( val ) for ( key , val ) in props . items () if key in field_map ) ) cls . _custom_mapping ( props , data ) print ( dict ( data )) self = cls ( ** data ) return self","title":"from_props"},{"location":"reference/yapapi/props/inf/#keys","text":"def keys ( ) View Source @classmethod def keys ( cls ) : class _Keys : def __init__ ( self , iter ) : self . __dict__ = dict ( iter ) return _Keys (( f . name , f . metadata [ \"key\" ] ) for f in fields ( cls ))","title":"keys"},{"location":"reference/yapapi/props/inf/#infvm","text":"class InfVm ( cores : int ) InfVm(cores: int) View Source class InfVm ( Model ): cores: int = field ( metadata ={ \"key\" : INF_CORES })","title":"InfVm"},{"location":"reference/yapapi/props/inf/#ancestors-in-mro_1","text":"yapapi.props.base.Model abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/yapapi/props/inf/#static-methods_1","text":"","title":"Static methods"},{"location":"reference/yapapi/props/inf/#from_props_1","text":"def from_props ( props : Dict [ str , str ] ) -> 'Model' View Source @classmethod def from_props ( cls , props : Props ) -> \"Model\" : field_map = dict ( ( f . metadata [ \"key\" ] , _PyField ( name = f . name , type = f . type , required = f . default is MISSING ), ) for f in fields ( cls ) if \"key\" in f . metadata ) data = dict ( ( field_map [ key ] . encode ( val ) for ( key , val ) in props . items () if key in field_map ) ) cls . _custom_mapping ( props , data ) print ( dict ( data )) self = cls ( ** data ) return self","title":"from_props"},{"location":"reference/yapapi/props/inf/#keys_1","text":"def keys ( ) View Source @classmethod def keys ( cls ) : class _Keys : def __init__ ( self , iter ) : self . __dict__ = dict ( iter ) return _Keys (( f . name , f . metadata [ \"key\" ] ) for f in fields ( cls ))","title":"keys"},{"location":"reference/yapapi/rest/","text":"Module yapapi.rest Mid level binding for Golem REST API View Source \"\"\" Mid level binding for Golem REST API \"\"\" from .configuration import Configuration from .market import Market __all__ = ( \"Configuration\" , \"Market\" ) Sub-modules yapapi.rest.configuration yapapi.rest.market Classes Configuration class Configuration ( app_key = None , url : Union [ str , NoneType ] = None , market_url : Union [ str , NoneType ] = None ) View Source class Configuration ( object ) : def __init__ ( self , app_key = None , url : Optional [ str ] = None , market_url : Optional [ str ] = None ) : self . _app_key : str = app_key or env_or_fail ( \"YAGNA_APPKEY\" , \"API authentication token\" ) self . _url = url or DEFAULT_API_URL self . _market_url : str = market_url or os . getenv ( \"YAGNA_MARKET_URL\" ) or f \"{self._url}/market-api/v1\" @property def app_key ( self ) -> str : return self . _app_key @property def market_url ( self ) -> str : return self . _market_url def market ( self ) -> ya_market . ApiClient : cfg = ya_market . Configuration ( host = self . market_url ) return ya_market . ApiClient ( configuration = cfg , header_name = \"authorization\" , header_value = f \"Bearer {self.app_key}\" , ) Instance variables app_key market_url Methods market def market ( self ) -> ya_market . api_client . ApiClient View Source def market ( self ) -> ya_market . ApiClient : cfg = ya_market . Configuration ( host = self . market_url ) return ya_market . ApiClient ( configuration = cfg , header_name = \"authorization\" , header_value = f \"Bearer {self.app_key}\" , ) Market class Market ( api_client : ya_market . api_client . ApiClient ) View Source class Market ( object ) : def __init__ ( self , api_client : ApiClient ) : self . _api : RequestorApi = RequestorApi ( api_client ) async def subscribe ( self , props , constraints ) -> Subscription : sub_id = await self . _api . subscribe_demand ( models . Demand ( properties = props , constraints = constraints ) ) return Subscription ( self . _api , sub_id ) async def subscriptions ( self ) -> Iterable [ Subscription ] : return ( Subscription ( self . _api , demand . demand_id ) for demand in await self . _api . get_demands () ) Methods subscribe def subscribe ( self , props , constraints ) -> yapapi . rest . market . Subscription View Source async def subscribe ( self , props , constraints ) -> Subscription : sub_id = await self . _api . subscribe_demand ( models . Demand ( properties = props , constraints = constraints ) ) return Subscription ( self . _api , sub_id ) subscriptions def subscriptions ( self ) -> Iterable [ yapapi . rest . market . Subscription ] View Source async def subscriptions ( self ) -> Iterable [ Subscription ] : return ( Subscription ( self . _api , demand . demand_id ) for demand in await self . _api . get_demands () )","title":"Index"},{"location":"reference/yapapi/rest/#module-yapapirest","text":"Mid level binding for Golem REST API View Source \"\"\" Mid level binding for Golem REST API \"\"\" from .configuration import Configuration from .market import Market __all__ = ( \"Configuration\" , \"Market\" )","title":"Module yapapi.rest"},{"location":"reference/yapapi/rest/#sub-modules","text":"yapapi.rest.configuration yapapi.rest.market","title":"Sub-modules"},{"location":"reference/yapapi/rest/#classes","text":"","title":"Classes"},{"location":"reference/yapapi/rest/#configuration","text":"class Configuration ( app_key = None , url : Union [ str , NoneType ] = None , market_url : Union [ str , NoneType ] = None ) View Source class Configuration ( object ) : def __init__ ( self , app_key = None , url : Optional [ str ] = None , market_url : Optional [ str ] = None ) : self . _app_key : str = app_key or env_or_fail ( \"YAGNA_APPKEY\" , \"API authentication token\" ) self . _url = url or DEFAULT_API_URL self . _market_url : str = market_url or os . getenv ( \"YAGNA_MARKET_URL\" ) or f \"{self._url}/market-api/v1\" @property def app_key ( self ) -> str : return self . _app_key @property def market_url ( self ) -> str : return self . _market_url def market ( self ) -> ya_market . ApiClient : cfg = ya_market . Configuration ( host = self . market_url ) return ya_market . ApiClient ( configuration = cfg , header_name = \"authorization\" , header_value = f \"Bearer {self.app_key}\" , )","title":"Configuration"},{"location":"reference/yapapi/rest/#instance-variables","text":"app_key market_url","title":"Instance variables"},{"location":"reference/yapapi/rest/#methods","text":"","title":"Methods"},{"location":"reference/yapapi/rest/#market","text":"def market ( self ) -> ya_market . api_client . ApiClient View Source def market ( self ) -> ya_market . ApiClient : cfg = ya_market . Configuration ( host = self . market_url ) return ya_market . ApiClient ( configuration = cfg , header_name = \"authorization\" , header_value = f \"Bearer {self.app_key}\" , )","title":"market"},{"location":"reference/yapapi/rest/#market_1","text":"class Market ( api_client : ya_market . api_client . ApiClient ) View Source class Market ( object ) : def __init__ ( self , api_client : ApiClient ) : self . _api : RequestorApi = RequestorApi ( api_client ) async def subscribe ( self , props , constraints ) -> Subscription : sub_id = await self . _api . subscribe_demand ( models . Demand ( properties = props , constraints = constraints ) ) return Subscription ( self . _api , sub_id ) async def subscriptions ( self ) -> Iterable [ Subscription ] : return ( Subscription ( self . _api , demand . demand_id ) for demand in await self . _api . get_demands () )","title":"Market"},{"location":"reference/yapapi/rest/#methods_1","text":"","title":"Methods"},{"location":"reference/yapapi/rest/#subscribe","text":"def subscribe ( self , props , constraints ) -> yapapi . rest . market . Subscription View Source async def subscribe ( self , props , constraints ) -> Subscription : sub_id = await self . _api . subscribe_demand ( models . Demand ( properties = props , constraints = constraints ) ) return Subscription ( self . _api , sub_id )","title":"subscribe"},{"location":"reference/yapapi/rest/#subscriptions","text":"def subscriptions ( self ) -> Iterable [ yapapi . rest . market . Subscription ] View Source async def subscriptions ( self ) -> Iterable [ Subscription ] : return ( Subscription ( self . _api , demand . demand_id ) for demand in await self . _api . get_demands () )","title":"subscriptions"},{"location":"reference/yapapi/rest/configuration/","text":"Module yapapi.rest.configuration View Source import os from dataclasses import dataclass from typing import Optional import ya_market DEFAULT_API_URL : str = \"http://127.0.0.1:7465\" class MissingConfiguration ( Exception ): def __init__ ( self , key : str , description : str ): self . _key = key self . _description = description def __str__ ( self ): return f \"Missing configuration for {self._description}. env var is {self._key}\" def env_or_fail ( key : str , description : str ) -> str : val = os . getenv ( key ) if val is None : raise MissingConfiguration ( key = key , description = description ) return val class Configuration ( object ): def __init__ ( self , app_key = None , url : Optional [ str ] = None , market_url : Optional [ str ] = None ): self . _app_key : str = app_key or env_or_fail ( \"YAGNA_APPKEY\" , \"API authentication token\" ) self . _url = url or DEFAULT_API_URL self . _market_url : str = market_url or os . getenv ( \"YAGNA_MARKET_URL\" ) or f \"{self._url}/market-api/v1\" @property def app_key ( self ) -> str : return self . _app_key @property def market_url ( self ) -> str : return self . _market_url def market ( self ) -> ya_market . ApiClient : cfg = ya_market . Configuration ( host = self . market_url ) return ya_market . ApiClient ( configuration = cfg , header_name = \"authorization\" , header_value = f \"Bearer {self.app_key}\" , ) Variables DEFAULT_API_URL Functions env_or_fail def env_or_fail ( key : str , description : str ) -> str View Source def env_or_fail ( key : str , description : str ) -> str : val = os . getenv ( key ) if val is None : raise MissingConfiguration ( key = key , description = description ) return val Classes Configuration class Configuration ( app_key = None , url : Union [ str , NoneType ] = None , market_url : Union [ str , NoneType ] = None ) View Source class Configuration ( object ) : def __init__ ( self , app_key = None , url : Optional [ str ] = None , market_url : Optional [ str ] = None ) : self . _app_key : str = app_key or env_or_fail ( \"YAGNA_APPKEY\" , \"API authentication token\" ) self . _url = url or DEFAULT_API_URL self . _market_url : str = market_url or os . getenv ( \"YAGNA_MARKET_URL\" ) or f \"{self._url}/market-api/v1\" @property def app_key ( self ) -> str : return self . _app_key @property def market_url ( self ) -> str : return self . _market_url def market ( self ) -> ya_market . ApiClient : cfg = ya_market . Configuration ( host = self . market_url ) return ya_market . ApiClient ( configuration = cfg , header_name = \"authorization\" , header_value = f \"Bearer {self.app_key}\" , ) Instance variables app_key market_url Methods market def market ( self ) -> ya_market . api_client . ApiClient View Source def market ( self ) -> ya_market . ApiClient : cfg = ya_market . Configuration ( host = self . market_url ) return ya_market . ApiClient ( configuration = cfg , header_name = \"authorization\" , header_value = f \"Bearer {self.app_key}\" , ) MissingConfiguration class MissingConfiguration ( key : str , description : str ) Common base class for all non-exit exceptions. View Source class MissingConfiguration ( Exception ): def __init__ ( self , key: str , description: str ): self . _key = key self . _description = description def __str__ ( self ): return f \"Missing configuration for {self._description}. env var is {self._key}\" Ancestors (in MRO) builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Configuration"},{"location":"reference/yapapi/rest/configuration/#module-yapapirestconfiguration","text":"View Source import os from dataclasses import dataclass from typing import Optional import ya_market DEFAULT_API_URL : str = \"http://127.0.0.1:7465\" class MissingConfiguration ( Exception ): def __init__ ( self , key : str , description : str ): self . _key = key self . _description = description def __str__ ( self ): return f \"Missing configuration for {self._description}. env var is {self._key}\" def env_or_fail ( key : str , description : str ) -> str : val = os . getenv ( key ) if val is None : raise MissingConfiguration ( key = key , description = description ) return val class Configuration ( object ): def __init__ ( self , app_key = None , url : Optional [ str ] = None , market_url : Optional [ str ] = None ): self . _app_key : str = app_key or env_or_fail ( \"YAGNA_APPKEY\" , \"API authentication token\" ) self . _url = url or DEFAULT_API_URL self . _market_url : str = market_url or os . getenv ( \"YAGNA_MARKET_URL\" ) or f \"{self._url}/market-api/v1\" @property def app_key ( self ) -> str : return self . _app_key @property def market_url ( self ) -> str : return self . _market_url def market ( self ) -> ya_market . ApiClient : cfg = ya_market . Configuration ( host = self . market_url ) return ya_market . ApiClient ( configuration = cfg , header_name = \"authorization\" , header_value = f \"Bearer {self.app_key}\" , )","title":"Module yapapi.rest.configuration"},{"location":"reference/yapapi/rest/configuration/#variables","text":"DEFAULT_API_URL","title":"Variables"},{"location":"reference/yapapi/rest/configuration/#functions","text":"","title":"Functions"},{"location":"reference/yapapi/rest/configuration/#env_or_fail","text":"def env_or_fail ( key : str , description : str ) -> str View Source def env_or_fail ( key : str , description : str ) -> str : val = os . getenv ( key ) if val is None : raise MissingConfiguration ( key = key , description = description ) return val","title":"env_or_fail"},{"location":"reference/yapapi/rest/configuration/#classes","text":"","title":"Classes"},{"location":"reference/yapapi/rest/configuration/#configuration","text":"class Configuration ( app_key = None , url : Union [ str , NoneType ] = None , market_url : Union [ str , NoneType ] = None ) View Source class Configuration ( object ) : def __init__ ( self , app_key = None , url : Optional [ str ] = None , market_url : Optional [ str ] = None ) : self . _app_key : str = app_key or env_or_fail ( \"YAGNA_APPKEY\" , \"API authentication token\" ) self . _url = url or DEFAULT_API_URL self . _market_url : str = market_url or os . getenv ( \"YAGNA_MARKET_URL\" ) or f \"{self._url}/market-api/v1\" @property def app_key ( self ) -> str : return self . _app_key @property def market_url ( self ) -> str : return self . _market_url def market ( self ) -> ya_market . ApiClient : cfg = ya_market . Configuration ( host = self . market_url ) return ya_market . ApiClient ( configuration = cfg , header_name = \"authorization\" , header_value = f \"Bearer {self.app_key}\" , )","title":"Configuration"},{"location":"reference/yapapi/rest/configuration/#instance-variables","text":"app_key market_url","title":"Instance variables"},{"location":"reference/yapapi/rest/configuration/#methods","text":"","title":"Methods"},{"location":"reference/yapapi/rest/configuration/#market","text":"def market ( self ) -> ya_market . api_client . ApiClient View Source def market ( self ) -> ya_market . ApiClient : cfg = ya_market . Configuration ( host = self . market_url ) return ya_market . ApiClient ( configuration = cfg , header_name = \"authorization\" , header_value = f \"Bearer {self.app_key}\" , )","title":"market"},{"location":"reference/yapapi/rest/configuration/#missingconfiguration","text":"class MissingConfiguration ( key : str , description : str ) Common base class for all non-exit exceptions. View Source class MissingConfiguration ( Exception ): def __init__ ( self , key: str , description: str ): self . _key = key self . _description = description def __str__ ( self ): return f \"Missing configuration for {self._description}. env var is {self._key}\"","title":"MissingConfiguration"},{"location":"reference/yapapi/rest/configuration/#ancestors-in-mro","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/yapapi/rest/configuration/#class-variables","text":"args","title":"Class variables"},{"location":"reference/yapapi/rest/configuration/#methods_1","text":"","title":"Methods"},{"location":"reference/yapapi/rest/configuration/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/yapapi/rest/market/","text":"Module yapapi.rest.market View Source import asyncio from dataclasses import dataclass from typing import AsyncIterator , Optional , Iterable from ya_market import ApiClient , RequestorApi , models from datetime import datetime , timedelta , timezone class Agreement ( object ): def __init__ ( self , api : RequestorApi , subscription : \"Subscription\" , agreement_id : str ): self . _api = api self . _subscription = subscription self . _id = agreement_id @property def id ( self ) -> str : return self . _id async def confirm ( self ): await self . _api . confirm_agreement ( self . _id ) class OfferProposal ( object ): def __init__ ( self , subscription : \"Subscription\" , proposal : models . ProposalEvent ): self . _proposal : models . ProposalEvent = proposal self . _subscription : \"Subscription\" = subscription @property def issuer ( self ) -> str : return self . _proposal . proposal . issuer_id @property def id ( self ) -> str : return self . _proposal . proposal . proposal_id @property def props ( self ): return self . _proposal . proposal . properties @property def is_draft ( self ) -> bool : return self . _proposal . proposal . state == \"Draft\" async def respond ( self , props : Optional [ object ] = None , constraints : Optional [ str ] = None ) -> str : proposal = models . Proposal ( properties = props , constraints = constraints ) new_proposal = await self . _subscription . _api . counter_proposal_demand ( self . _subscription . id , self . id , proposal ) return new_proposal async def agreement ( self , timeout = timedelta ( minutes = 2 )) -> Agreement : proposal = models . AgreementProposal ( proposal_id = self . id , valid_to = datetime . now ( timezone . utc ) + timeout , ) api : RequestorApi = self . _subscription . _api agreement_id = await api . create_agreement ( proposal ) return Agreement ( api , self . _subscription , agreement_id ) def __str__ ( self ): proposal = self . _proposal . proposal return f \"\"\"OfferProposal( id={proposal.proposal_id} state={proposal.state} issuer={proposal.issuer_id} )\"\"\" class Subscription ( object ): def __init__ ( self , api : RequestorApi , subscription_id : str ): self . _api : RequestorApi = api self . _id : str = subscription_id self . _open : bool = True self . _deleted = False @property def id ( self ): return self . _id def close ( self ): self . _open = False async def __aenter__ ( self ) -> \"Subscription\" : return self async def __aexit__ ( self , exc_type , exc_value , traceback ): await self . delete () async def delete ( self ): self . _open = False if not self . _deleted : await self . _api . unsubscribe_demand ( self . _id ) async def events ( self ) -> AsyncIterator [ OfferProposal ]: while self . _open : proposals = await self . _api . collect_offers ( self . _id , timeout = 10 , max_events = 10 ) for proposal in proposals : yield OfferProposal ( self , proposal ) if not proposals : await asyncio . sleep ( 1 ) class Market ( object ): def __init__ ( self , api_client : ApiClient ): self . _api : RequestorApi = RequestorApi ( api_client ) async def subscribe ( self , props , constraints ) -> Subscription : sub_id = await self . _api . subscribe_demand ( models . Demand ( properties = props , constraints = constraints ) ) return Subscription ( self . _api , sub_id ) async def subscriptions ( self ) -> Iterable [ Subscription ]: return ( Subscription ( self . _api , demand . demand_id ) for demand in await self . _api . get_demands () ) Classes Agreement class Agreement ( api : ya_market . api . requestor_api . RequestorApi , subscription : 'Subscription' , agreement_id : str ) View Source class Agreement ( object ) : def __init__ ( self , api : RequestorApi , subscription : \"Subscription\" , agreement_id : str ) : self . _api = api self . _subscription = subscription self . _id = agreement_id @property def id ( self ) -> str : return self . _id async def confirm ( self ) : await self . _api . confirm_agreement ( self . _id ) Instance variables id Methods confirm def confirm ( self ) View Source async def confirm ( self ): await self . _api . confirm_agreement ( self . _id ) Market class Market ( api_client : ya_market . api_client . ApiClient ) View Source class Market ( object ) : def __init__ ( self , api_client : ApiClient ) : self . _api : RequestorApi = RequestorApi ( api_client ) async def subscribe ( self , props , constraints ) -> Subscription : sub_id = await self . _api . subscribe_demand ( models . Demand ( properties = props , constraints = constraints ) ) return Subscription ( self . _api , sub_id ) async def subscriptions ( self ) -> Iterable [ Subscription ] : return ( Subscription ( self . _api , demand . demand_id ) for demand in await self . _api . get_demands () ) Methods subscribe def subscribe ( self , props , constraints ) -> yapapi . rest . market . Subscription View Source async def subscribe ( self , props , constraints ) -> Subscription : sub_id = await self . _api . subscribe_demand ( models . Demand ( properties = props , constraints = constraints ) ) return Subscription ( self . _api , sub_id ) subscriptions def subscriptions ( self ) -> Iterable [ yapapi . rest . market . Subscription ] View Source async def subscriptions ( self ) -> Iterable [ Subscription ] : return ( Subscription ( self . _api , demand . demand_id ) for demand in await self . _api . get_demands () ) OfferProposal class OfferProposal ( subscription : 'Subscription' , proposal : ya_market . models . proposal_event . ProposalEvent ) View Source class OfferProposal ( object ) : def __init__ ( self , subscription : \"Subscription\" , proposal : models . ProposalEvent ) : self . _proposal : models . ProposalEvent = proposal self . _subscription : \"Subscription\" = subscription @property def issuer ( self ) -> str : return self . _proposal . proposal . issuer_id @property def id ( self ) -> str : return self . _proposal . proposal . proposal_id @property def props ( self ) : return self . _proposal . proposal . properties @property def is_draft ( self ) -> bool : return self . _proposal . proposal . state == \"Draft\" async def respond ( self , props : Optional [ object ] = None , constraints : Optional [ str ] = None ) -> str : proposal = models . Proposal ( properties = props , constraints = constraints ) new_proposal = await self . _subscription . _api . counter_proposal_demand ( self . _subscription . id , self . id , proposal ) return new_proposal async def agreement ( self , timeout = timedelta ( minutes = 2 )) -> Agreement : proposal = models . AgreementProposal ( proposal_id = self . id , valid_to = datetime . now ( timezone . utc ) + timeout , ) api : RequestorApi = self . _subscription . _api agreement_id = await api . create_agreement ( proposal ) return Agreement ( api , self . _subscription , agreement_id ) def __str__ ( self ) : proposal = self . _proposal . proposal return f \"\"\"OfferProposal( id={proposal.proposal_id} state={proposal.state} issuer={proposal.issuer_id} )\"\"\" Instance variables id is_draft issuer props Methods agreement def agreement ( self , timeout = datetime . timedelta ( seconds = 120 ) ) -> yapapi . rest . market . Agreement View Source async def agreement ( self , timeout = timedelta ( minutes = 2 )) -> Agreement : proposal = models . AgreementProposal ( proposal_id = self . id , valid_to = datetime . now ( timezone . utc ) + timeout , ) api : RequestorApi = self . _subscription . _api agreement_id = await api . create_agreement ( proposal ) return Agreement ( api , self . _subscription , agreement_id ) respond def respond ( self , props : Union [ object , NoneType ] = None , constraints : Union [ str , NoneType ] = None ) -> str View Source async def respond ( self , props : Optional [ object ] = None , constraints : Optional [ str ] = None ) -> str : proposal = models . Proposal ( properties = props , constraints = constraints ) new_proposal = await self . _subscription . _api . counter_proposal_demand ( self . _subscription . id , self . id , proposal ) return new_proposal Subscription class Subscription ( api : ya_market . api . requestor_api . RequestorApi , subscription_id : str ) View Source class Subscription ( object ) : def __init__ ( self , api : RequestorApi , subscription_id : str ) : self . _api : RequestorApi = api self . _id : str = subscription_id self . _open : bool = True self . _deleted = False @property def id ( self ) : return self . _id def close ( self ) : self . _open = False async def __aenter__ ( self ) -> \"Subscription\" : return self async def __aexit__ ( self , exc_type , exc_value , traceback ) : await self . delete () async def delete ( self ) : self . _open = False if not self . _deleted : await self . _api . unsubscribe_demand ( self . _id ) async def events ( self ) -> AsyncIterator [ OfferProposal ] : while self . _open : proposals = await self . _api . collect_offers ( self . _id , timeout = 10 , max_events = 10 ) for proposal in proposals : yield OfferProposal ( self , proposal ) if not proposals : await asyncio . sleep ( 1 ) Instance variables id Methods close def close ( self ) View Source def close ( self ): self . _open = False delete def delete ( self ) View Source async def delete ( self ): self . _open = False if not self . _deleted : await self . _api . unsubscribe_demand ( self . _id ) events def events ( self ) -> AsyncIterator [ yapapi . rest . market . OfferProposal ] View Source async def events ( self ) -> AsyncIterator [ OfferProposal ] : while self . _open : proposals = await self . _api . collect_offers ( self . _id , timeout = 10 , max_events = 10 ) for proposal in proposals : yield OfferProposal ( self , proposal ) if not proposals : await asyncio . sleep ( 1 )","title":"Market"},{"location":"reference/yapapi/rest/market/#module-yapapirestmarket","text":"View Source import asyncio from dataclasses import dataclass from typing import AsyncIterator , Optional , Iterable from ya_market import ApiClient , RequestorApi , models from datetime import datetime , timedelta , timezone class Agreement ( object ): def __init__ ( self , api : RequestorApi , subscription : \"Subscription\" , agreement_id : str ): self . _api = api self . _subscription = subscription self . _id = agreement_id @property def id ( self ) -> str : return self . _id async def confirm ( self ): await self . _api . confirm_agreement ( self . _id ) class OfferProposal ( object ): def __init__ ( self , subscription : \"Subscription\" , proposal : models . ProposalEvent ): self . _proposal : models . ProposalEvent = proposal self . _subscription : \"Subscription\" = subscription @property def issuer ( self ) -> str : return self . _proposal . proposal . issuer_id @property def id ( self ) -> str : return self . _proposal . proposal . proposal_id @property def props ( self ): return self . _proposal . proposal . properties @property def is_draft ( self ) -> bool : return self . _proposal . proposal . state == \"Draft\" async def respond ( self , props : Optional [ object ] = None , constraints : Optional [ str ] = None ) -> str : proposal = models . Proposal ( properties = props , constraints = constraints ) new_proposal = await self . _subscription . _api . counter_proposal_demand ( self . _subscription . id , self . id , proposal ) return new_proposal async def agreement ( self , timeout = timedelta ( minutes = 2 )) -> Agreement : proposal = models . AgreementProposal ( proposal_id = self . id , valid_to = datetime . now ( timezone . utc ) + timeout , ) api : RequestorApi = self . _subscription . _api agreement_id = await api . create_agreement ( proposal ) return Agreement ( api , self . _subscription , agreement_id ) def __str__ ( self ): proposal = self . _proposal . proposal return f \"\"\"OfferProposal( id={proposal.proposal_id} state={proposal.state} issuer={proposal.issuer_id} )\"\"\" class Subscription ( object ): def __init__ ( self , api : RequestorApi , subscription_id : str ): self . _api : RequestorApi = api self . _id : str = subscription_id self . _open : bool = True self . _deleted = False @property def id ( self ): return self . _id def close ( self ): self . _open = False async def __aenter__ ( self ) -> \"Subscription\" : return self async def __aexit__ ( self , exc_type , exc_value , traceback ): await self . delete () async def delete ( self ): self . _open = False if not self . _deleted : await self . _api . unsubscribe_demand ( self . _id ) async def events ( self ) -> AsyncIterator [ OfferProposal ]: while self . _open : proposals = await self . _api . collect_offers ( self . _id , timeout = 10 , max_events = 10 ) for proposal in proposals : yield OfferProposal ( self , proposal ) if not proposals : await asyncio . sleep ( 1 ) class Market ( object ): def __init__ ( self , api_client : ApiClient ): self . _api : RequestorApi = RequestorApi ( api_client ) async def subscribe ( self , props , constraints ) -> Subscription : sub_id = await self . _api . subscribe_demand ( models . Demand ( properties = props , constraints = constraints ) ) return Subscription ( self . _api , sub_id ) async def subscriptions ( self ) -> Iterable [ Subscription ]: return ( Subscription ( self . _api , demand . demand_id ) for demand in await self . _api . get_demands () )","title":"Module yapapi.rest.market"},{"location":"reference/yapapi/rest/market/#classes","text":"","title":"Classes"},{"location":"reference/yapapi/rest/market/#agreement","text":"class Agreement ( api : ya_market . api . requestor_api . RequestorApi , subscription : 'Subscription' , agreement_id : str ) View Source class Agreement ( object ) : def __init__ ( self , api : RequestorApi , subscription : \"Subscription\" , agreement_id : str ) : self . _api = api self . _subscription = subscription self . _id = agreement_id @property def id ( self ) -> str : return self . _id async def confirm ( self ) : await self . _api . confirm_agreement ( self . _id )","title":"Agreement"},{"location":"reference/yapapi/rest/market/#instance-variables","text":"id","title":"Instance variables"},{"location":"reference/yapapi/rest/market/#methods","text":"","title":"Methods"},{"location":"reference/yapapi/rest/market/#confirm","text":"def confirm ( self ) View Source async def confirm ( self ): await self . _api . confirm_agreement ( self . _id )","title":"confirm"},{"location":"reference/yapapi/rest/market/#market","text":"class Market ( api_client : ya_market . api_client . ApiClient ) View Source class Market ( object ) : def __init__ ( self , api_client : ApiClient ) : self . _api : RequestorApi = RequestorApi ( api_client ) async def subscribe ( self , props , constraints ) -> Subscription : sub_id = await self . _api . subscribe_demand ( models . Demand ( properties = props , constraints = constraints ) ) return Subscription ( self . _api , sub_id ) async def subscriptions ( self ) -> Iterable [ Subscription ] : return ( Subscription ( self . _api , demand . demand_id ) for demand in await self . _api . get_demands () )","title":"Market"},{"location":"reference/yapapi/rest/market/#methods_1","text":"","title":"Methods"},{"location":"reference/yapapi/rest/market/#subscribe","text":"def subscribe ( self , props , constraints ) -> yapapi . rest . market . Subscription View Source async def subscribe ( self , props , constraints ) -> Subscription : sub_id = await self . _api . subscribe_demand ( models . Demand ( properties = props , constraints = constraints ) ) return Subscription ( self . _api , sub_id )","title":"subscribe"},{"location":"reference/yapapi/rest/market/#subscriptions","text":"def subscriptions ( self ) -> Iterable [ yapapi . rest . market . Subscription ] View Source async def subscriptions ( self ) -> Iterable [ Subscription ] : return ( Subscription ( self . _api , demand . demand_id ) for demand in await self . _api . get_demands () )","title":"subscriptions"},{"location":"reference/yapapi/rest/market/#offerproposal","text":"class OfferProposal ( subscription : 'Subscription' , proposal : ya_market . models . proposal_event . ProposalEvent ) View Source class OfferProposal ( object ) : def __init__ ( self , subscription : \"Subscription\" , proposal : models . ProposalEvent ) : self . _proposal : models . ProposalEvent = proposal self . _subscription : \"Subscription\" = subscription @property def issuer ( self ) -> str : return self . _proposal . proposal . issuer_id @property def id ( self ) -> str : return self . _proposal . proposal . proposal_id @property def props ( self ) : return self . _proposal . proposal . properties @property def is_draft ( self ) -> bool : return self . _proposal . proposal . state == \"Draft\" async def respond ( self , props : Optional [ object ] = None , constraints : Optional [ str ] = None ) -> str : proposal = models . Proposal ( properties = props , constraints = constraints ) new_proposal = await self . _subscription . _api . counter_proposal_demand ( self . _subscription . id , self . id , proposal ) return new_proposal async def agreement ( self , timeout = timedelta ( minutes = 2 )) -> Agreement : proposal = models . AgreementProposal ( proposal_id = self . id , valid_to = datetime . now ( timezone . utc ) + timeout , ) api : RequestorApi = self . _subscription . _api agreement_id = await api . create_agreement ( proposal ) return Agreement ( api , self . _subscription , agreement_id ) def __str__ ( self ) : proposal = self . _proposal . proposal return f \"\"\"OfferProposal( id={proposal.proposal_id} state={proposal.state} issuer={proposal.issuer_id} )\"\"\"","title":"OfferProposal"},{"location":"reference/yapapi/rest/market/#instance-variables_1","text":"id is_draft issuer props","title":"Instance variables"},{"location":"reference/yapapi/rest/market/#methods_2","text":"","title":"Methods"},{"location":"reference/yapapi/rest/market/#agreement_1","text":"def agreement ( self , timeout = datetime . timedelta ( seconds = 120 ) ) -> yapapi . rest . market . Agreement View Source async def agreement ( self , timeout = timedelta ( minutes = 2 )) -> Agreement : proposal = models . AgreementProposal ( proposal_id = self . id , valid_to = datetime . now ( timezone . utc ) + timeout , ) api : RequestorApi = self . _subscription . _api agreement_id = await api . create_agreement ( proposal ) return Agreement ( api , self . _subscription , agreement_id )","title":"agreement"},{"location":"reference/yapapi/rest/market/#respond","text":"def respond ( self , props : Union [ object , NoneType ] = None , constraints : Union [ str , NoneType ] = None ) -> str View Source async def respond ( self , props : Optional [ object ] = None , constraints : Optional [ str ] = None ) -> str : proposal = models . Proposal ( properties = props , constraints = constraints ) new_proposal = await self . _subscription . _api . counter_proposal_demand ( self . _subscription . id , self . id , proposal ) return new_proposal","title":"respond"},{"location":"reference/yapapi/rest/market/#subscription","text":"class Subscription ( api : ya_market . api . requestor_api . RequestorApi , subscription_id : str ) View Source class Subscription ( object ) : def __init__ ( self , api : RequestorApi , subscription_id : str ) : self . _api : RequestorApi = api self . _id : str = subscription_id self . _open : bool = True self . _deleted = False @property def id ( self ) : return self . _id def close ( self ) : self . _open = False async def __aenter__ ( self ) -> \"Subscription\" : return self async def __aexit__ ( self , exc_type , exc_value , traceback ) : await self . delete () async def delete ( self ) : self . _open = False if not self . _deleted : await self . _api . unsubscribe_demand ( self . _id ) async def events ( self ) -> AsyncIterator [ OfferProposal ] : while self . _open : proposals = await self . _api . collect_offers ( self . _id , timeout = 10 , max_events = 10 ) for proposal in proposals : yield OfferProposal ( self , proposal ) if not proposals : await asyncio . sleep ( 1 )","title":"Subscription"},{"location":"reference/yapapi/rest/market/#instance-variables_2","text":"id","title":"Instance variables"},{"location":"reference/yapapi/rest/market/#methods_3","text":"","title":"Methods"},{"location":"reference/yapapi/rest/market/#close","text":"def close ( self ) View Source def close ( self ): self . _open = False","title":"close"},{"location":"reference/yapapi/rest/market/#delete","text":"def delete ( self ) View Source async def delete ( self ): self . _open = False if not self . _deleted : await self . _api . unsubscribe_demand ( self . _id )","title":"delete"},{"location":"reference/yapapi/rest/market/#events","text":"def events ( self ) -> AsyncIterator [ yapapi . rest . market . OfferProposal ] View Source async def events ( self ) -> AsyncIterator [ OfferProposal ] : while self . _open : proposals = await self . _api . collect_offers ( self . _id , timeout = 10 , max_events = 10 ) for proposal in proposals : yield OfferProposal ( self , proposal ) if not proposals : await asyncio . sleep ( 1 )","title":"events"},{"location":"reference/yapapi/runner/","text":"Module yapapi.runner View Source from datetime import datetime , timedelta from enum import Enum , auto from typing import Optional import abc from dataclasses import dataclass class Engine ( object ): pass class TaskStatus ( Enum ): WAITING = auto () RUNNING = auto () ACCEPTED = auto () REJECTED = auto () class Task : def __init__ ( self , * , expires : Optional [ datetime ] = None , timeout : Optional [ timedelta ] = None , ** kwargs ): self . _started = datetime . now () self . _expires : Optional [ datetime ] if timeout : self . _expires = self . _started + timeout else : self . _expires = expires self . _data = kwargs self . _status : TaskStatus = TaskStatus . WAITING def __getattr__ ( self , item ): return self . _data . get ( item ) @property def expires ( self ): return self . _expires def accept_task ( self ): assert self . _status == TaskStatus . RUNNING self . _status = TaskStatus . ACCEPTED def reject_task ( self ): assert self . _status == TaskStatus . RUNNING self . _status = TaskStatus . REJECTED class Package ( abc . ABC ): pass Sub-modules yapapi.runner.vm Classes Engine class Engine ( / , * args , ** kwargs ) View Source class Engine ( object ): pass Package class Package ( / , * args , ** kwargs ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Package ( abc . ABC ): pass Ancestors (in MRO) abc.ABC Task class Task ( * , expires : Union [ datetime . datetime , NoneType ] = None , timeout : Union [ datetime . timedelta , NoneType ] = None , ** kwargs ) View Source class Task : def __init__ ( self , * , expires : Optional [ datetime ] = None , timeout : Optional [ timedelta ] = None , ** kwargs ) : self . _started = datetime . now () self . _expires : Optional [ datetime ] if timeout : self . _expires = self . _started + timeout else : self . _expires = expires self . _data = kwargs self . _status : TaskStatus = TaskStatus . WAITING def __getattr__ ( self , item ) : return self . _data . get ( item ) @property def expires ( self ) : return self . _expires def accept_task ( self ) : assert self . _status == TaskStatus . RUNNING self . _status = TaskStatus . ACCEPTED def reject_task ( self ) : assert self . _status == TaskStatus . RUNNING self . _status = TaskStatus . REJECTED Instance variables expires Methods accept_task def accept_task ( self ) View Source def accept_task ( self ): assert self . _status == TaskStatus . RUNNING self . _status = TaskStatus . ACCEPTED reject_task def reject_task ( self ) View Source def reject_task ( self ): assert self . _status == TaskStatus . RUNNING self . _status = TaskStatus . REJECTED TaskStatus class TaskStatus ( / , * args , ** kwargs ) An enumeration. View Source class TaskStatus ( Enum ): WAITING = auto () RUNNING = auto () ACCEPTED = auto () REJECTED = auto () Ancestors (in MRO) enum.Enum Class variables ACCEPTED REJECTED RUNNING WAITING name value","title":"Index"},{"location":"reference/yapapi/runner/#module-yapapirunner","text":"View Source from datetime import datetime , timedelta from enum import Enum , auto from typing import Optional import abc from dataclasses import dataclass class Engine ( object ): pass class TaskStatus ( Enum ): WAITING = auto () RUNNING = auto () ACCEPTED = auto () REJECTED = auto () class Task : def __init__ ( self , * , expires : Optional [ datetime ] = None , timeout : Optional [ timedelta ] = None , ** kwargs ): self . _started = datetime . now () self . _expires : Optional [ datetime ] if timeout : self . _expires = self . _started + timeout else : self . _expires = expires self . _data = kwargs self . _status : TaskStatus = TaskStatus . WAITING def __getattr__ ( self , item ): return self . _data . get ( item ) @property def expires ( self ): return self . _expires def accept_task ( self ): assert self . _status == TaskStatus . RUNNING self . _status = TaskStatus . ACCEPTED def reject_task ( self ): assert self . _status == TaskStatus . RUNNING self . _status = TaskStatus . REJECTED class Package ( abc . ABC ): pass","title":"Module yapapi.runner"},{"location":"reference/yapapi/runner/#sub-modules","text":"yapapi.runner.vm","title":"Sub-modules"},{"location":"reference/yapapi/runner/#classes","text":"","title":"Classes"},{"location":"reference/yapapi/runner/#engine","text":"class Engine ( / , * args , ** kwargs ) View Source class Engine ( object ): pass","title":"Engine"},{"location":"reference/yapapi/runner/#package","text":"class Package ( / , * args , ** kwargs ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Package ( abc . ABC ): pass","title":"Package"},{"location":"reference/yapapi/runner/#ancestors-in-mro","text":"abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/yapapi/runner/#task","text":"class Task ( * , expires : Union [ datetime . datetime , NoneType ] = None , timeout : Union [ datetime . timedelta , NoneType ] = None , ** kwargs ) View Source class Task : def __init__ ( self , * , expires : Optional [ datetime ] = None , timeout : Optional [ timedelta ] = None , ** kwargs ) : self . _started = datetime . now () self . _expires : Optional [ datetime ] if timeout : self . _expires = self . _started + timeout else : self . _expires = expires self . _data = kwargs self . _status : TaskStatus = TaskStatus . WAITING def __getattr__ ( self , item ) : return self . _data . get ( item ) @property def expires ( self ) : return self . _expires def accept_task ( self ) : assert self . _status == TaskStatus . RUNNING self . _status = TaskStatus . ACCEPTED def reject_task ( self ) : assert self . _status == TaskStatus . RUNNING self . _status = TaskStatus . REJECTED","title":"Task"},{"location":"reference/yapapi/runner/#instance-variables","text":"expires","title":"Instance variables"},{"location":"reference/yapapi/runner/#methods","text":"","title":"Methods"},{"location":"reference/yapapi/runner/#accept_task","text":"def accept_task ( self ) View Source def accept_task ( self ): assert self . _status == TaskStatus . RUNNING self . _status = TaskStatus . ACCEPTED","title":"accept_task"},{"location":"reference/yapapi/runner/#reject_task","text":"def reject_task ( self ) View Source def reject_task ( self ): assert self . _status == TaskStatus . RUNNING self . _status = TaskStatus . REJECTED","title":"reject_task"},{"location":"reference/yapapi/runner/#taskstatus","text":"class TaskStatus ( / , * args , ** kwargs ) An enumeration. View Source class TaskStatus ( Enum ): WAITING = auto () RUNNING = auto () ACCEPTED = auto () REJECTED = auto ()","title":"TaskStatus"},{"location":"reference/yapapi/runner/#ancestors-in-mro_1","text":"enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/yapapi/runner/#class-variables","text":"ACCEPTED REJECTED RUNNING WAITING name value","title":"Class variables"},{"location":"reference/yapapi/runner/vm/","text":"Module yapapi.runner.vm View Source from . import Package def repo ( * , image_hash : str ) -> Package : raise NotImplemented Functions repo def repo ( * , image_hash : str ) -> yapapi . runner . Package View Source def repo ( * , image_hash : str ) -> Package : raise NotImplemented","title":"Vm"},{"location":"reference/yapapi/runner/vm/#module-yapapirunnervm","text":"View Source from . import Package def repo ( * , image_hash : str ) -> Package : raise NotImplemented","title":"Module yapapi.runner.vm"},{"location":"reference/yapapi/runner/vm/#functions","text":"","title":"Functions"},{"location":"reference/yapapi/runner/vm/#repo","text":"def repo ( * , image_hash : str ) -> yapapi . runner . Package View Source def repo ( * , image_hash : str ) -> Package : raise NotImplemented","title":"repo"},{"location":"reference/yapapi/storage/","text":"Module yapapi.storage Storage models. View Source \"\"\" Storage models. \"\"\" import abc , os , pathlib , io from os import PathLike from typing import AsyncIterator , NamedTuple , Union , Optional import asyncio , aiohttp _BUF_SIZE = 40960 AsyncReader = Union [ asyncio . streams . StreamReader , aiohttp . streams . StreamReader ] class Content ( NamedTuple ): length : int stream : AsyncIterator [ bytes ] @classmethod def from_reader ( cls , length : int , s : AsyncReader ): async def stream () -> AsyncIterator [ bytes ]: while not s . at_eof (): buf = await s . read ( _BUF_SIZE ) yield buf return Content ( length , stream ()) class Source ( abc . ABC ): @property @abc.abstractmethod def download_url ( self ) -> str : raise NotImplemented @abc.abstractmethod async def content_length ( self ) -> int : raise NotImplemented class Destination ( abc . ABC ): @property @abc.abstractmethod def upload_url ( self ) -> str : raise NotImplemented @abc.abstractmethod async def download_stream ( self ) -> Content : raise NotImplemented async def download_file ( self , destination_file : PathLike ): content = await self . download_stream () with open ( destination_file , \"wb\" ) as f : async for chunk in content . stream : f . write ( chunk ) class InputStorageProvider ( abc . ABC ): @abc.abstractmethod async def upload_stream ( self , length : int , stream : AsyncIterator [ bytes ]) -> Source : raise NotImplemented async def upload_file ( self , path : os . PathLike ) -> Source : fp = pathlib . Path ( path ) file_size = fp . stat () . st_size async def read_file (): with io . open ( path , \"rb\" ) as f : while True : b : bytes = f . read ( _BUF_SIZE ) if not b : break yield b return await self . upload_stream ( file_size , read_file ()) class OutputStorageProvider ( abc . ABC ): @abc.abstractmethod async def new_destination ( self , destination_file : Optional [ PathLike ] = None ) -> Destination : \"\"\" Creates slot for receiving file. :param destination_file: Optional hint where received data should be placed. :return: \"\"\" raise NotImplemented class StorageProvider ( InputStorageProvider , OutputStorageProvider , abc . ABC ): pass class ComposedStorageProvider ( StorageProvider ): def __init__ ( self , input_storage : InputStorageProvider , output_storage : OutputStorageProvider ): self . _input = input_storage self . _output = output_storage async def upload_stream ( self , length : int , stream : AsyncIterator [ bytes ]) -> Source : return await self . _input . upload_stream ( length , stream ) async def upload_file ( self , path : os . PathLike ) -> Source : return await self . _input . upload_file ( path ) async def new_destination ( self , destination_file : Optional [ PathLike ] = None ) -> Destination : return await self . _output . new_destination ( destination_file ) Sub-modules yapapi.storage.gftp yapapi.storage.webdav Variables AsyncReader Classes ComposedStorageProvider class ComposedStorageProvider ( input_storage : yapapi . storage . InputStorageProvider , output_storage : yapapi . storage . OutputStorageProvider ) Helper class that provides a standard way to create an ABC using inheritance. View Source class ComposedStorageProvider ( StorageProvider ) : def __init__ ( self , input_storage : InputStorageProvider , output_storage : OutputStorageProvider ) : self . _input = input_storage self . _output = output_storage async def upload_stream ( self , length : int , stream : AsyncIterator [ bytes ] ) -> Source : return await self . _input . upload_stream ( length , stream ) async def upload_file ( self , path : os . PathLike ) -> Source : return await self . _input . upload_file ( path ) async def new_destination ( self , destination_file : Optional [ PathLike ] = None ) -> Destination : return await self . _output . new_destination ( destination_file ) Ancestors (in MRO) yapapi.storage.StorageProvider yapapi.storage.InputStorageProvider yapapi.storage.OutputStorageProvider abc.ABC Methods new_destination def new_destination ( self , destination_file : Union [ os . PathLike , NoneType ] = None ) -> yapapi . storage . Destination Creates slot for receiving file. :param destination_file: Optional hint where received data should be placed. :return: View Source async def new_destination ( self , destination_file : Optional [ PathLike ] = None ) -> Destination : return await self . _output . new_destination ( destination_file ) upload_file def upload_file ( self , path : os . PathLike ) -> yapapi . storage . Source View Source async def upload_file ( self , path : os . PathLike ) -> Source : return await self . _input . upload_file ( path ) upload_stream def upload_stream ( self , length : int , stream : AsyncIterator [ bytes ] ) -> yapapi . storage . Source View Source async def upload_stream ( self , length : int , stream : AsyncIterator [ bytes ] ) -> Source : return await self . _input . upload_stream ( length , stream ) Content class Content ( / , * args , ** kwargs ) Content(length, stream) View Source class Content ( NamedTuple ) : length : int stream : AsyncIterator [ bytes ] @classmethod def from_reader ( cls , length : int , s : AsyncReader ) : async def stream () -> AsyncIterator [ bytes ] : while not s . at_eof () : buf = await s . read ( _BUF_SIZE ) yield buf return Content ( length , stream ()) Ancestors (in MRO) builtins.tuple Class variables length stream Static methods from_reader def from_reader ( length : int , s : Union [ asyncio . streams . StreamReader , aiohttp . streams . StreamReader ] ) View Source @classmethod def from_reader ( cls , length : int , s : AsyncReader ) : async def stream () -> AsyncIterator [ bytes ] : while not s . at_eof () : buf = await s . read ( _BUF_SIZE ) yield buf return Content ( length , stream ()) Methods count def count ( self , value , / ) Return number of occurrences of value. index def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present. Destination class Destination ( / , * args , ** kwargs ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Destination ( abc . ABC ) : @property @abc . abstractmethod def upload_url ( self ) -> str : raise NotImplemented @abc . abstractmethod async def download_stream ( self ) -> Content : raise NotImplemented async def download_file ( self , destination_file : PathLike ) : content = await self . download_stream () with open ( destination_file , \"wb\" ) as f : async for chunk in content . stream : f . write ( chunk ) Ancestors (in MRO) abc.ABC Descendants yapapi.storage.webdav._DavDestination Instance variables upload_url Methods download_file def download_file ( self , destination_file : os . PathLike ) View Source async def download_file ( self , destination_file : PathLike ): content = await self . download_stream () with open ( destination_file , \"wb\" ) as f : async for chunk in content . stream : f . write ( chunk ) download_stream def download_stream ( self ) -> yapapi . storage . Content View Source @abc . abstractmethod async def download_stream ( self ) -> Content : raise NotImplemented InputStorageProvider class InputStorageProvider ( / , * args , ** kwargs ) Helper class that provides a standard way to create an ABC using inheritance. View Source class InputStorageProvider ( abc . ABC ) : @abc . abstractmethod async def upload_stream ( self , length : int , stream : AsyncIterator [ bytes ] ) -> Source : raise NotImplemented async def upload_file ( self , path : os . PathLike ) -> Source : fp = pathlib . Path ( path ) file_size = fp . stat (). st_size async def read_file () : with io . open ( path , \"rb\" ) as f : while True : b : bytes = f . read ( _BUF_SIZE ) if not b : break yield b return await self . upload_stream ( file_size , read_file ()) Ancestors (in MRO) abc.ABC Descendants yapapi.storage.StorageProvider Methods upload_file def upload_file ( self , path : os . PathLike ) -> yapapi . storage . Source View Source async def upload_file ( self , path : os . PathLike ) -> Source : fp = pathlib . Path ( path ) file_size = fp . stat (). st_size async def read_file (): with io . open ( path , \"rb\" ) as f : while True : b : bytes = f . read ( _BUF_SIZE ) if not b : break yield b return await self . upload_stream ( file_size , read_file ()) upload_stream def upload_stream ( self , length : int , stream : AsyncIterator [ bytes ] ) -> yapapi . storage . Source View Source @abc . abstractmethod async def upload_stream ( self , length : int , stream : AsyncIterator [ bytes ] ) -> Source : raise NotImplemented OutputStorageProvider class OutputStorageProvider ( / , * args , ** kwargs ) Helper class that provides a standard way to create an ABC using inheritance. View Source class OutputStorageProvider ( abc . ABC ) : @abc . abstractmethod async def new_destination ( self , destination_file : Optional [ PathLike ] = None ) -> Destination : \"\"\" Creates slot for receiving file. :param destination_file: Optional hint where received data should be placed. :return: \"\"\" raise NotImplemented Ancestors (in MRO) abc.ABC Descendants yapapi.storage.StorageProvider Methods new_destination def new_destination ( self , destination_file : Union [ os . PathLike , NoneType ] = None ) -> yapapi . storage . Destination Creates slot for receiving file. :param destination_file: Optional hint where received data should be placed. :return: View Source @abc . abstractmethod async def new_destination ( self , destination_file : Optional [ PathLike ] = None ) -> Destination : \"\"\" Creates slot for receiving file. :param destination_file: Optional hint where received data should be placed. :return: \"\"\" raise NotImplemented Source class Source ( / , * args , ** kwargs ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Source ( abc . ABC ) : @property @abc . abstractmethod def download_url ( self ) -> str : raise NotImplemented @abc . abstractmethod async def content_length ( self ) -> int : raise NotImplemented Ancestors (in MRO) abc.ABC Descendants yapapi.storage.webdav._DavSource Instance variables download_url Methods content_length def content_length ( self ) -> int View Source @abc . abstractmethod async def content_length ( self ) -> int : raise NotImplemented StorageProvider class StorageProvider ( / , * args , ** kwargs ) Helper class that provides a standard way to create an ABC using inheritance. View Source class StorageProvider ( InputStorageProvider , OutputStorageProvider , abc . ABC ): pass Ancestors (in MRO) yapapi.storage.InputStorageProvider yapapi.storage.OutputStorageProvider abc.ABC Descendants yapapi.storage.ComposedStorageProvider yapapi.storage.webdav.DavStorageProvider Methods new_destination def new_destination ( self , destination_file : Union [ os . PathLike , NoneType ] = None ) -> yapapi . storage . Destination Creates slot for receiving file. :param destination_file: Optional hint where received data should be placed. :return: View Source @abc . abstractmethod async def new_destination ( self , destination_file : Optional [ PathLike ] = None ) -> Destination : \"\"\" Creates slot for receiving file. :param destination_file: Optional hint where received data should be placed. :return: \"\"\" raise NotImplemented upload_file def upload_file ( self , path : os . PathLike ) -> yapapi . storage . Source View Source async def upload_file ( self , path : os . PathLike ) -> Source : fp = pathlib . Path ( path ) file_size = fp . stat (). st_size async def read_file (): with io . open ( path , \"rb\" ) as f : while True : b : bytes = f . read ( _BUF_SIZE ) if not b : break yield b return await self . upload_stream ( file_size , read_file ()) upload_stream def upload_stream ( self , length : int , stream : AsyncIterator [ bytes ] ) -> yapapi . storage . Source View Source @abc . abstractmethod async def upload_stream ( self , length : int , stream : AsyncIterator [ bytes ] ) -> Source : raise NotImplemented","title":"Index"},{"location":"reference/yapapi/storage/#module-yapapistorage","text":"Storage models. View Source \"\"\" Storage models. \"\"\" import abc , os , pathlib , io from os import PathLike from typing import AsyncIterator , NamedTuple , Union , Optional import asyncio , aiohttp _BUF_SIZE = 40960 AsyncReader = Union [ asyncio . streams . StreamReader , aiohttp . streams . StreamReader ] class Content ( NamedTuple ): length : int stream : AsyncIterator [ bytes ] @classmethod def from_reader ( cls , length : int , s : AsyncReader ): async def stream () -> AsyncIterator [ bytes ]: while not s . at_eof (): buf = await s . read ( _BUF_SIZE ) yield buf return Content ( length , stream ()) class Source ( abc . ABC ): @property @abc.abstractmethod def download_url ( self ) -> str : raise NotImplemented @abc.abstractmethod async def content_length ( self ) -> int : raise NotImplemented class Destination ( abc . ABC ): @property @abc.abstractmethod def upload_url ( self ) -> str : raise NotImplemented @abc.abstractmethod async def download_stream ( self ) -> Content : raise NotImplemented async def download_file ( self , destination_file : PathLike ): content = await self . download_stream () with open ( destination_file , \"wb\" ) as f : async for chunk in content . stream : f . write ( chunk ) class InputStorageProvider ( abc . ABC ): @abc.abstractmethod async def upload_stream ( self , length : int , stream : AsyncIterator [ bytes ]) -> Source : raise NotImplemented async def upload_file ( self , path : os . PathLike ) -> Source : fp = pathlib . Path ( path ) file_size = fp . stat () . st_size async def read_file (): with io . open ( path , \"rb\" ) as f : while True : b : bytes = f . read ( _BUF_SIZE ) if not b : break yield b return await self . upload_stream ( file_size , read_file ()) class OutputStorageProvider ( abc . ABC ): @abc.abstractmethod async def new_destination ( self , destination_file : Optional [ PathLike ] = None ) -> Destination : \"\"\" Creates slot for receiving file. :param destination_file: Optional hint where received data should be placed. :return: \"\"\" raise NotImplemented class StorageProvider ( InputStorageProvider , OutputStorageProvider , abc . ABC ): pass class ComposedStorageProvider ( StorageProvider ): def __init__ ( self , input_storage : InputStorageProvider , output_storage : OutputStorageProvider ): self . _input = input_storage self . _output = output_storage async def upload_stream ( self , length : int , stream : AsyncIterator [ bytes ]) -> Source : return await self . _input . upload_stream ( length , stream ) async def upload_file ( self , path : os . PathLike ) -> Source : return await self . _input . upload_file ( path ) async def new_destination ( self , destination_file : Optional [ PathLike ] = None ) -> Destination : return await self . _output . new_destination ( destination_file )","title":"Module yapapi.storage"},{"location":"reference/yapapi/storage/#sub-modules","text":"yapapi.storage.gftp yapapi.storage.webdav","title":"Sub-modules"},{"location":"reference/yapapi/storage/#variables","text":"AsyncReader","title":"Variables"},{"location":"reference/yapapi/storage/#classes","text":"","title":"Classes"},{"location":"reference/yapapi/storage/#composedstorageprovider","text":"class ComposedStorageProvider ( input_storage : yapapi . storage . InputStorageProvider , output_storage : yapapi . storage . OutputStorageProvider ) Helper class that provides a standard way to create an ABC using inheritance. View Source class ComposedStorageProvider ( StorageProvider ) : def __init__ ( self , input_storage : InputStorageProvider , output_storage : OutputStorageProvider ) : self . _input = input_storage self . _output = output_storage async def upload_stream ( self , length : int , stream : AsyncIterator [ bytes ] ) -> Source : return await self . _input . upload_stream ( length , stream ) async def upload_file ( self , path : os . PathLike ) -> Source : return await self . _input . upload_file ( path ) async def new_destination ( self , destination_file : Optional [ PathLike ] = None ) -> Destination : return await self . _output . new_destination ( destination_file )","title":"ComposedStorageProvider"},{"location":"reference/yapapi/storage/#ancestors-in-mro","text":"yapapi.storage.StorageProvider yapapi.storage.InputStorageProvider yapapi.storage.OutputStorageProvider abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/yapapi/storage/#methods","text":"","title":"Methods"},{"location":"reference/yapapi/storage/#new_destination","text":"def new_destination ( self , destination_file : Union [ os . PathLike , NoneType ] = None ) -> yapapi . storage . Destination Creates slot for receiving file. :param destination_file: Optional hint where received data should be placed. :return: View Source async def new_destination ( self , destination_file : Optional [ PathLike ] = None ) -> Destination : return await self . _output . new_destination ( destination_file )","title":"new_destination"},{"location":"reference/yapapi/storage/#upload_file","text":"def upload_file ( self , path : os . PathLike ) -> yapapi . storage . Source View Source async def upload_file ( self , path : os . PathLike ) -> Source : return await self . _input . upload_file ( path )","title":"upload_file"},{"location":"reference/yapapi/storage/#upload_stream","text":"def upload_stream ( self , length : int , stream : AsyncIterator [ bytes ] ) -> yapapi . storage . Source View Source async def upload_stream ( self , length : int , stream : AsyncIterator [ bytes ] ) -> Source : return await self . _input . upload_stream ( length , stream )","title":"upload_stream"},{"location":"reference/yapapi/storage/#content","text":"class Content ( / , * args , ** kwargs ) Content(length, stream) View Source class Content ( NamedTuple ) : length : int stream : AsyncIterator [ bytes ] @classmethod def from_reader ( cls , length : int , s : AsyncReader ) : async def stream () -> AsyncIterator [ bytes ] : while not s . at_eof () : buf = await s . read ( _BUF_SIZE ) yield buf return Content ( length , stream ())","title":"Content"},{"location":"reference/yapapi/storage/#ancestors-in-mro_1","text":"builtins.tuple","title":"Ancestors (in MRO)"},{"location":"reference/yapapi/storage/#class-variables","text":"length stream","title":"Class variables"},{"location":"reference/yapapi/storage/#static-methods","text":"","title":"Static methods"},{"location":"reference/yapapi/storage/#from_reader","text":"def from_reader ( length : int , s : Union [ asyncio . streams . StreamReader , aiohttp . streams . StreamReader ] ) View Source @classmethod def from_reader ( cls , length : int , s : AsyncReader ) : async def stream () -> AsyncIterator [ bytes ] : while not s . at_eof () : buf = await s . read ( _BUF_SIZE ) yield buf return Content ( length , stream ())","title":"from_reader"},{"location":"reference/yapapi/storage/#methods_1","text":"","title":"Methods"},{"location":"reference/yapapi/storage/#count","text":"def count ( self , value , / ) Return number of occurrences of value.","title":"count"},{"location":"reference/yapapi/storage/#index","text":"def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present.","title":"index"},{"location":"reference/yapapi/storage/#destination","text":"class Destination ( / , * args , ** kwargs ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Destination ( abc . ABC ) : @property @abc . abstractmethod def upload_url ( self ) -> str : raise NotImplemented @abc . abstractmethod async def download_stream ( self ) -> Content : raise NotImplemented async def download_file ( self , destination_file : PathLike ) : content = await self . download_stream () with open ( destination_file , \"wb\" ) as f : async for chunk in content . stream : f . write ( chunk )","title":"Destination"},{"location":"reference/yapapi/storage/#ancestors-in-mro_2","text":"abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/yapapi/storage/#descendants","text":"yapapi.storage.webdav._DavDestination","title":"Descendants"},{"location":"reference/yapapi/storage/#instance-variables","text":"upload_url","title":"Instance variables"},{"location":"reference/yapapi/storage/#methods_2","text":"","title":"Methods"},{"location":"reference/yapapi/storage/#download_file","text":"def download_file ( self , destination_file : os . PathLike ) View Source async def download_file ( self , destination_file : PathLike ): content = await self . download_stream () with open ( destination_file , \"wb\" ) as f : async for chunk in content . stream : f . write ( chunk )","title":"download_file"},{"location":"reference/yapapi/storage/#download_stream","text":"def download_stream ( self ) -> yapapi . storage . Content View Source @abc . abstractmethod async def download_stream ( self ) -> Content : raise NotImplemented","title":"download_stream"},{"location":"reference/yapapi/storage/#inputstorageprovider","text":"class InputStorageProvider ( / , * args , ** kwargs ) Helper class that provides a standard way to create an ABC using inheritance. View Source class InputStorageProvider ( abc . ABC ) : @abc . abstractmethod async def upload_stream ( self , length : int , stream : AsyncIterator [ bytes ] ) -> Source : raise NotImplemented async def upload_file ( self , path : os . PathLike ) -> Source : fp = pathlib . Path ( path ) file_size = fp . stat (). st_size async def read_file () : with io . open ( path , \"rb\" ) as f : while True : b : bytes = f . read ( _BUF_SIZE ) if not b : break yield b return await self . upload_stream ( file_size , read_file ())","title":"InputStorageProvider"},{"location":"reference/yapapi/storage/#ancestors-in-mro_3","text":"abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/yapapi/storage/#descendants_1","text":"yapapi.storage.StorageProvider","title":"Descendants"},{"location":"reference/yapapi/storage/#methods_3","text":"","title":"Methods"},{"location":"reference/yapapi/storage/#upload_file_1","text":"def upload_file ( self , path : os . PathLike ) -> yapapi . storage . Source View Source async def upload_file ( self , path : os . PathLike ) -> Source : fp = pathlib . Path ( path ) file_size = fp . stat (). st_size async def read_file (): with io . open ( path , \"rb\" ) as f : while True : b : bytes = f . read ( _BUF_SIZE ) if not b : break yield b return await self . upload_stream ( file_size , read_file ())","title":"upload_file"},{"location":"reference/yapapi/storage/#upload_stream_1","text":"def upload_stream ( self , length : int , stream : AsyncIterator [ bytes ] ) -> yapapi . storage . Source View Source @abc . abstractmethod async def upload_stream ( self , length : int , stream : AsyncIterator [ bytes ] ) -> Source : raise NotImplemented","title":"upload_stream"},{"location":"reference/yapapi/storage/#outputstorageprovider","text":"class OutputStorageProvider ( / , * args , ** kwargs ) Helper class that provides a standard way to create an ABC using inheritance. View Source class OutputStorageProvider ( abc . ABC ) : @abc . abstractmethod async def new_destination ( self , destination_file : Optional [ PathLike ] = None ) -> Destination : \"\"\" Creates slot for receiving file. :param destination_file: Optional hint where received data should be placed. :return: \"\"\" raise NotImplemented","title":"OutputStorageProvider"},{"location":"reference/yapapi/storage/#ancestors-in-mro_4","text":"abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/yapapi/storage/#descendants_2","text":"yapapi.storage.StorageProvider","title":"Descendants"},{"location":"reference/yapapi/storage/#methods_4","text":"","title":"Methods"},{"location":"reference/yapapi/storage/#new_destination_1","text":"def new_destination ( self , destination_file : Union [ os . PathLike , NoneType ] = None ) -> yapapi . storage . Destination Creates slot for receiving file. :param destination_file: Optional hint where received data should be placed. :return: View Source @abc . abstractmethod async def new_destination ( self , destination_file : Optional [ PathLike ] = None ) -> Destination : \"\"\" Creates slot for receiving file. :param destination_file: Optional hint where received data should be placed. :return: \"\"\" raise NotImplemented","title":"new_destination"},{"location":"reference/yapapi/storage/#source","text":"class Source ( / , * args , ** kwargs ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Source ( abc . ABC ) : @property @abc . abstractmethod def download_url ( self ) -> str : raise NotImplemented @abc . abstractmethod async def content_length ( self ) -> int : raise NotImplemented","title":"Source"},{"location":"reference/yapapi/storage/#ancestors-in-mro_5","text":"abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/yapapi/storage/#descendants_3","text":"yapapi.storage.webdav._DavSource","title":"Descendants"},{"location":"reference/yapapi/storage/#instance-variables_1","text":"download_url","title":"Instance variables"},{"location":"reference/yapapi/storage/#methods_5","text":"","title":"Methods"},{"location":"reference/yapapi/storage/#content_length","text":"def content_length ( self ) -> int View Source @abc . abstractmethod async def content_length ( self ) -> int : raise NotImplemented","title":"content_length"},{"location":"reference/yapapi/storage/#storageprovider","text":"class StorageProvider ( / , * args , ** kwargs ) Helper class that provides a standard way to create an ABC using inheritance. View Source class StorageProvider ( InputStorageProvider , OutputStorageProvider , abc . ABC ): pass","title":"StorageProvider"},{"location":"reference/yapapi/storage/#ancestors-in-mro_6","text":"yapapi.storage.InputStorageProvider yapapi.storage.OutputStorageProvider abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/yapapi/storage/#descendants_4","text":"yapapi.storage.ComposedStorageProvider yapapi.storage.webdav.DavStorageProvider","title":"Descendants"},{"location":"reference/yapapi/storage/#methods_6","text":"","title":"Methods"},{"location":"reference/yapapi/storage/#new_destination_2","text":"def new_destination ( self , destination_file : Union [ os . PathLike , NoneType ] = None ) -> yapapi . storage . Destination Creates slot for receiving file. :param destination_file: Optional hint where received data should be placed. :return: View Source @abc . abstractmethod async def new_destination ( self , destination_file : Optional [ PathLike ] = None ) -> Destination : \"\"\" Creates slot for receiving file. :param destination_file: Optional hint where received data should be placed. :return: \"\"\" raise NotImplemented","title":"new_destination"},{"location":"reference/yapapi/storage/#upload_file_2","text":"def upload_file ( self , path : os . PathLike ) -> yapapi . storage . Source View Source async def upload_file ( self , path : os . PathLike ) -> Source : fp = pathlib . Path ( path ) file_size = fp . stat (). st_size async def read_file (): with io . open ( path , \"rb\" ) as f : while True : b : bytes = f . read ( _BUF_SIZE ) if not b : break yield b return await self . upload_stream ( file_size , read_file ())","title":"upload_file"},{"location":"reference/yapapi/storage/#upload_stream_2","text":"def upload_stream ( self , length : int , stream : AsyncIterator [ bytes ] ) -> yapapi . storage . Source View Source @abc . abstractmethod async def upload_stream ( self , length : int , stream : AsyncIterator [ bytes ] ) -> Source : raise NotImplemented","title":"upload_stream"},{"location":"reference/yapapi/storage/gftp/","text":"Module yapapi.storage.gftp Golem File Transfer Storage Provider View Source \"\"\" Golem File Transfer Storage Provider \"\"\" from enum import Enum class _Command ( Enum ): EXPORT = \"export\" IMPORT = \"import\" LIST = \"list\" DONE = \"done\"","title":"Gftp"},{"location":"reference/yapapi/storage/gftp/#module-yapapistoragegftp","text":"Golem File Transfer Storage Provider View Source \"\"\" Golem File Transfer Storage Provider \"\"\" from enum import Enum class _Command ( Enum ): EXPORT = \"export\" IMPORT = \"import\" LIST = \"list\" DONE = \"done\"","title":"Module yapapi.storage.gftp"},{"location":"reference/yapapi/storage/webdav/","text":"Module yapapi.storage.webdav View Source from os import PathLike from typing import Optional , AsyncIterator , List , NamedTuple from . import StorageProvider , Source , Destination , Content import aiohttp , uuid from dataclasses import dataclass from datetime import datetime import logging from urllib.parse import urlparse , urljoin , ParseResult _logger : logging . Logger = logging . getLogger ( __name__ ) class DavResource ( NamedTuple ): path : str length : int collection : bool last_modified : Optional [ datetime ] = None def _parse_prop_resp ( xml : str ) -> List [ DavResource ]: from io import StringIO from xml.etree import ElementTree from email.utils import parsedate_to_datetime tree = ElementTree . parse ( StringIO ( xml )) def resource ( element : ElementTree . Element ) -> DavResource : href = element . findtext ( \"{DAV:}href\" ) prop = element . find ( \"{DAV:}propstat\" ) if prop is not None : prop = prop . find ( \"{DAV:}prop\" ) if prop is None or href is None : raise RuntimeError ( \"missing props in xml response\" ) length = prop . findtext ( \"{DAV:}getcontentlength\" ) resource_type = prop . find ( \"{DAV:}resourcetype\" ) last_modified = prop . findtext ( \"{DAV:}getlastmodified\" ) collection = ( resource_type . find ( \"{DAV:}collection\" ) is not None if resource_type else False ) return DavResource ( path = href , length = 0 if length is None else int ( length ), collection = collection , last_modified = None if last_modified is None else parsedate_to_datetime ( last_modified ), ) return list ( map ( resource , tree . findall ( \"{DAV:}response\" ))) class _DavSource ( Source ): def __init__ ( self , url : str , length : Optional [ int ] = None ): self . _url = url self . _length = length @property def download_url ( self ) -> str : return self . _url async def content_length ( self ) -> int : if self . _length : return self . _length async with aiohttp . ClientSession () as session : async with session . get ( url = self . _url ) as resp : if resp . status != 200 : raise RuntimeError ( \"invalid url\" ) if resp . content_length is None : raise RuntimeError ( \"invalid response missing length\" ) return resp . content_length class _DavDestination ( Destination ): def __init__ ( self , client : aiohttp . ClientSession , url : str ): self . _client = client self . _url = url @property def upload_url ( self ) -> str : return self . _url async def download_stream ( self ) -> Content : resp = await self . _client . get ( self . _url ) length = resp . content_length if length is None : raise RuntimeError ( \"missing content-length\" ) return Content . from_reader ( length , resp . content ) @dataclass class DavStorageProvider ( StorageProvider ): client : aiohttp . ClientSession base_url : str auth : Optional [ aiohttp . BasicAuth ] = None def __post_init__ ( self ): if self . base_url [ - 1 ] != \"/\" : self . base_url += \"/\" @classmethod async def for_directory ( cls , client : aiohttp . ClientSession , base_url : str , directory_name : str , auth : Optional [ aiohttp . BasicAuth ] = None , ** kwargs , ) -> \"DavStorageProvider\" : if base_url [ - 1 ] != \"/\" : base_url += \"/\" col_url = urljoin ( base_url , directory_name ) response = await client . request ( method = \"MKCOL\" , url = col_url , auth = auth ) if response . status != 201 : response . raise_for_status () return cls ( client , col_url , auth = auth ) async def upload_stream ( self , length : int , stream : AsyncIterator [ bytes ]) -> Source : upload_url = self . __new_url () resp = await self . client . request ( method = \"PUT\" , url = upload_url , data = stream , auth = self . auth ) _logger . debug ( \"upload done: %i \" , resp . status ) if resp . status != 201 : raise RuntimeError ( f \"invalid response for url: {upload_url}, {resp.status}/{resp.reason}\" ) return _DavSource ( self . __export_url ( upload_url )) async def new_destination ( self , destination_file : Optional [ PathLike ] = None ) -> Destination : upload_url = self . __new_url () return _DavDestination ( self . client , self . __export_url ( upload_url )) async def prop_find ( self ): headers = { \"content-type\" : \"text/xml\" , \"depth\" : \"1\" } data = \"\"\"<?xml version=\"1.0\"?> <a:propfind xmlns:a=\"DAV:\"> <a:prop> <a:resourcetype/> <a:getcontentlength/> <a:getlastmodified/> </a:prop> </a:propfind>\"\"\" async with self . client . request ( method = \"PROPFIND\" , url = self . base_url , auth = self . auth , headers = headers , data = data , ) as response : if response . status != 200 : response . raise_for_status () return _parse_prop_resp ( await response . text ()) def __export_url ( self , url ) -> str : if self . auth : parsed_url = urlparse ( url ) login , password , * _ = self . auth return parsed_url . _replace ( netloc = f \"{login}:{password}@{parsed_url.netloc}\" ) . geturl () else : return url def __new_url ( self ): name = uuid . uuid4 () return urljoin ( self . base_url , str ( name )) Classes DavResource class DavResource ( / , * args , ** kwargs ) DavResource(path, length, collection, last_modified) View Source class DavResource ( NamedTuple ) : path : str length : int collection : bool last_modified : Optional [ datetime ] = None Ancestors (in MRO) builtins.tuple Class variables collection last_modified length path Methods count def count ( self , value , / ) Return number of occurrences of value. index def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present. DavStorageProvider class DavStorageProvider ( client : aiohttp . client . ClientSession , base_url : str , auth : Union [ aiohttp . helpers . BasicAuth , NoneType ] = None ) DavStorageProvider(client: aiohttp.client.ClientSession, base_url: str, auth: Union[aiohttp.helpers.BasicAuth, NoneType] = None) View Source class DavStorageProvider ( StorageProvider ) : client : aiohttp . ClientSession base_url : str auth : Optional [ aiohttp.BasicAuth ] = None def __post_init__ ( self ) : if self . base_url [ -1 ] != \"/\" : self . base_url += \"/\" @classmethod async def for_directory ( cls , client : aiohttp . ClientSession , base_url : str , directory_name : str , auth : Optional [ aiohttp.BasicAuth ] = None , ** kwargs , ) -> \"DavStorageProvider\" : if base_url [ -1 ] != \"/\" : base_url += \"/\" col_url = urljoin ( base_url , directory_name ) response = await client . request ( method = \"MKCOL\" , url = col_url , auth = auth ) if response . status != 201 : response . raise_for_status () return cls ( client , col_url , auth = auth ) async def upload_stream ( self , length : int , stream : AsyncIterator [ bytes ] ) -> Source : upload_url = self . __new_url () resp = await self . client . request ( method = \"PUT\" , url = upload_url , data = stream , auth = self . auth ) _logger . debug ( \"upload done: %i\" , resp . status ) if resp . status != 201 : raise RuntimeError ( f \"invalid response for url: {upload_url}, {resp.status}/{resp.reason}\" ) return _DavSource ( self . __export_url ( upload_url )) async def new_destination ( self , destination_file : Optional [ PathLike ] = None ) -> Destination : upload_url = self . __new_url () return _DavDestination ( self . client , self . __export_url ( upload_url )) async def prop_find ( self ) : headers = { \"content-type\" : \"text/xml\" , \"depth\" : \"1\" } data = \"\"\"<?xml version=\" 1.0 \"?> <a:propfind xmlns:a=\" DAV : \"> <a:prop> <a:resourcetype/> <a:getcontentlength/> <a:getlastmodified/> </a:prop> </a:propfind>\"\"\" async with self . client . request ( method = \"PROPFIND\" , url = self . base_url , auth = self . auth , headers = headers , data = data , ) as response : if response . status != 200 : response . raise_for_status () return _parse_prop_resp ( await response . text ()) def __export_url ( self , url ) -> str : if self . auth : parsed_url = urlparse ( url ) login , password , * _ = self . auth return parsed_url . _replace ( netloc = f \"{login}:{password}@{parsed_url.netloc}\" ). geturl () else : return url def __new_url ( self ) : name = uuid . uuid4 () return urljoin ( self . base_url , str ( name )) Ancestors (in MRO) yapapi.storage.StorageProvider yapapi.storage.InputStorageProvider yapapi.storage.OutputStorageProvider abc.ABC Class variables auth Static methods for_directory def for_directory ( client : aiohttp . client . ClientSession , base_url : str , directory_name : str , auth : Union [ aiohttp . helpers . BasicAuth , NoneType ] = None , ** kwargs ) -> 'DavStorageProvider' View Source @classmethod async def for_directory ( cls , client : aiohttp . ClientSession , base_url : str , directory_name : str , auth : Optional [ aiohttp.BasicAuth ] = None , ** kwargs , ) -> \"DavStorageProvider\" : if base_url [ -1 ] != \"/\" : base_url += \"/\" col_url = urljoin ( base_url , directory_name ) response = await client . request ( method = \"MKCOL\" , url = col_url , auth = auth ) if response . status != 201 : response . raise_for_status () return cls ( client , col_url , auth = auth ) Methods new_destination def new_destination ( self , destination_file : Union [ os . PathLike , NoneType ] = None ) -> yapapi . storage . Destination Creates slot for receiving file. :param destination_file: Optional hint where received data should be placed. :return: View Source async def new_destination ( self , destination_file : Optional [ PathLike ] = None ) -> Destination : upload_url = self . __new_url () return _DavDestination ( self . client , self . __export_url ( upload_url )) prop_find def prop_find ( self ) View Source async def prop_find(self): headers = {\"content-type\": \"text/xml\", \"depth\": \"1\"} data = \"\"\" <?xml version=\"1.0\"?> <a:propfind xmlns:a= \"DAV:\" > <a:prop> <a:resourcetype/> <a:getcontentlength/> <a:getlastmodified/> </a:prop> </a:propfind> \"\"\" async with self.client.request( method=\"PROPFIND\", url=self.base_url, auth=self.auth, headers=headers, data=data, ) as response: if response.status != 200: response.raise_for_status() return _parse_prop_resp(await response.text()) upload_file def upload_file ( self , path : os . PathLike ) -> yapapi . storage . Source View Source async def upload_file ( self , path : os . PathLike ) -> Source : fp = pathlib . Path ( path ) file_size = fp . stat (). st_size async def read_file (): with io . open ( path , \"rb\" ) as f : while True : b : bytes = f . read ( _BUF_SIZE ) if not b : break yield b return await self . upload_stream ( file_size , read_file ()) upload_stream def upload_stream ( self , length : int , stream : AsyncIterator [ bytes ] ) -> yapapi . storage . Source View Source async def upload_stream ( self , length : int , stream : AsyncIterator [ bytes ] ) -> Source : upload_url = self . __new_url () resp = await self . client . request ( method = \"PUT\" , url = upload_url , data = stream , auth = self . auth ) _logger . debug ( \"upload done: %i\" , resp . status ) if resp . status != 201 : raise RuntimeError ( f \"invalid response for url: {upload_url}, {resp.status}/{resp.reason}\" ) return _DavSource ( self . __export_url ( upload_url ))","title":"Webdav"},{"location":"reference/yapapi/storage/webdav/#module-yapapistoragewebdav","text":"View Source from os import PathLike from typing import Optional , AsyncIterator , List , NamedTuple from . import StorageProvider , Source , Destination , Content import aiohttp , uuid from dataclasses import dataclass from datetime import datetime import logging from urllib.parse import urlparse , urljoin , ParseResult _logger : logging . Logger = logging . getLogger ( __name__ ) class DavResource ( NamedTuple ): path : str length : int collection : bool last_modified : Optional [ datetime ] = None def _parse_prop_resp ( xml : str ) -> List [ DavResource ]: from io import StringIO from xml.etree import ElementTree from email.utils import parsedate_to_datetime tree = ElementTree . parse ( StringIO ( xml )) def resource ( element : ElementTree . Element ) -> DavResource : href = element . findtext ( \"{DAV:}href\" ) prop = element . find ( \"{DAV:}propstat\" ) if prop is not None : prop = prop . find ( \"{DAV:}prop\" ) if prop is None or href is None : raise RuntimeError ( \"missing props in xml response\" ) length = prop . findtext ( \"{DAV:}getcontentlength\" ) resource_type = prop . find ( \"{DAV:}resourcetype\" ) last_modified = prop . findtext ( \"{DAV:}getlastmodified\" ) collection = ( resource_type . find ( \"{DAV:}collection\" ) is not None if resource_type else False ) return DavResource ( path = href , length = 0 if length is None else int ( length ), collection = collection , last_modified = None if last_modified is None else parsedate_to_datetime ( last_modified ), ) return list ( map ( resource , tree . findall ( \"{DAV:}response\" ))) class _DavSource ( Source ): def __init__ ( self , url : str , length : Optional [ int ] = None ): self . _url = url self . _length = length @property def download_url ( self ) -> str : return self . _url async def content_length ( self ) -> int : if self . _length : return self . _length async with aiohttp . ClientSession () as session : async with session . get ( url = self . _url ) as resp : if resp . status != 200 : raise RuntimeError ( \"invalid url\" ) if resp . content_length is None : raise RuntimeError ( \"invalid response missing length\" ) return resp . content_length class _DavDestination ( Destination ): def __init__ ( self , client : aiohttp . ClientSession , url : str ): self . _client = client self . _url = url @property def upload_url ( self ) -> str : return self . _url async def download_stream ( self ) -> Content : resp = await self . _client . get ( self . _url ) length = resp . content_length if length is None : raise RuntimeError ( \"missing content-length\" ) return Content . from_reader ( length , resp . content ) @dataclass class DavStorageProvider ( StorageProvider ): client : aiohttp . ClientSession base_url : str auth : Optional [ aiohttp . BasicAuth ] = None def __post_init__ ( self ): if self . base_url [ - 1 ] != \"/\" : self . base_url += \"/\" @classmethod async def for_directory ( cls , client : aiohttp . ClientSession , base_url : str , directory_name : str , auth : Optional [ aiohttp . BasicAuth ] = None , ** kwargs , ) -> \"DavStorageProvider\" : if base_url [ - 1 ] != \"/\" : base_url += \"/\" col_url = urljoin ( base_url , directory_name ) response = await client . request ( method = \"MKCOL\" , url = col_url , auth = auth ) if response . status != 201 : response . raise_for_status () return cls ( client , col_url , auth = auth ) async def upload_stream ( self , length : int , stream : AsyncIterator [ bytes ]) -> Source : upload_url = self . __new_url () resp = await self . client . request ( method = \"PUT\" , url = upload_url , data = stream , auth = self . auth ) _logger . debug ( \"upload done: %i \" , resp . status ) if resp . status != 201 : raise RuntimeError ( f \"invalid response for url: {upload_url}, {resp.status}/{resp.reason}\" ) return _DavSource ( self . __export_url ( upload_url )) async def new_destination ( self , destination_file : Optional [ PathLike ] = None ) -> Destination : upload_url = self . __new_url () return _DavDestination ( self . client , self . __export_url ( upload_url )) async def prop_find ( self ): headers = { \"content-type\" : \"text/xml\" , \"depth\" : \"1\" } data = \"\"\"<?xml version=\"1.0\"?> <a:propfind xmlns:a=\"DAV:\"> <a:prop> <a:resourcetype/> <a:getcontentlength/> <a:getlastmodified/> </a:prop> </a:propfind>\"\"\" async with self . client . request ( method = \"PROPFIND\" , url = self . base_url , auth = self . auth , headers = headers , data = data , ) as response : if response . status != 200 : response . raise_for_status () return _parse_prop_resp ( await response . text ()) def __export_url ( self , url ) -> str : if self . auth : parsed_url = urlparse ( url ) login , password , * _ = self . auth return parsed_url . _replace ( netloc = f \"{login}:{password}@{parsed_url.netloc}\" ) . geturl () else : return url def __new_url ( self ): name = uuid . uuid4 () return urljoin ( self . base_url , str ( name ))","title":"Module yapapi.storage.webdav"},{"location":"reference/yapapi/storage/webdav/#classes","text":"","title":"Classes"},{"location":"reference/yapapi/storage/webdav/#davresource","text":"class DavResource ( / , * args , ** kwargs ) DavResource(path, length, collection, last_modified) View Source class DavResource ( NamedTuple ) : path : str length : int collection : bool last_modified : Optional [ datetime ] = None","title":"DavResource"},{"location":"reference/yapapi/storage/webdav/#ancestors-in-mro","text":"builtins.tuple","title":"Ancestors (in MRO)"},{"location":"reference/yapapi/storage/webdav/#class-variables","text":"collection last_modified length path","title":"Class variables"},{"location":"reference/yapapi/storage/webdav/#methods","text":"","title":"Methods"},{"location":"reference/yapapi/storage/webdav/#count","text":"def count ( self , value , / ) Return number of occurrences of value.","title":"count"},{"location":"reference/yapapi/storage/webdav/#index","text":"def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present.","title":"index"},{"location":"reference/yapapi/storage/webdav/#davstorageprovider","text":"class DavStorageProvider ( client : aiohttp . client . ClientSession , base_url : str , auth : Union [ aiohttp . helpers . BasicAuth , NoneType ] = None ) DavStorageProvider(client: aiohttp.client.ClientSession, base_url: str, auth: Union[aiohttp.helpers.BasicAuth, NoneType] = None) View Source class DavStorageProvider ( StorageProvider ) : client : aiohttp . ClientSession base_url : str auth : Optional [ aiohttp.BasicAuth ] = None def __post_init__ ( self ) : if self . base_url [ -1 ] != \"/\" : self . base_url += \"/\" @classmethod async def for_directory ( cls , client : aiohttp . ClientSession , base_url : str , directory_name : str , auth : Optional [ aiohttp.BasicAuth ] = None , ** kwargs , ) -> \"DavStorageProvider\" : if base_url [ -1 ] != \"/\" : base_url += \"/\" col_url = urljoin ( base_url , directory_name ) response = await client . request ( method = \"MKCOL\" , url = col_url , auth = auth ) if response . status != 201 : response . raise_for_status () return cls ( client , col_url , auth = auth ) async def upload_stream ( self , length : int , stream : AsyncIterator [ bytes ] ) -> Source : upload_url = self . __new_url () resp = await self . client . request ( method = \"PUT\" , url = upload_url , data = stream , auth = self . auth ) _logger . debug ( \"upload done: %i\" , resp . status ) if resp . status != 201 : raise RuntimeError ( f \"invalid response for url: {upload_url}, {resp.status}/{resp.reason}\" ) return _DavSource ( self . __export_url ( upload_url )) async def new_destination ( self , destination_file : Optional [ PathLike ] = None ) -> Destination : upload_url = self . __new_url () return _DavDestination ( self . client , self . __export_url ( upload_url )) async def prop_find ( self ) : headers = { \"content-type\" : \"text/xml\" , \"depth\" : \"1\" } data = \"\"\"<?xml version=\" 1.0 \"?> <a:propfind xmlns:a=\" DAV : \"> <a:prop> <a:resourcetype/> <a:getcontentlength/> <a:getlastmodified/> </a:prop> </a:propfind>\"\"\" async with self . client . request ( method = \"PROPFIND\" , url = self . base_url , auth = self . auth , headers = headers , data = data , ) as response : if response . status != 200 : response . raise_for_status () return _parse_prop_resp ( await response . text ()) def __export_url ( self , url ) -> str : if self . auth : parsed_url = urlparse ( url ) login , password , * _ = self . auth return parsed_url . _replace ( netloc = f \"{login}:{password}@{parsed_url.netloc}\" ). geturl () else : return url def __new_url ( self ) : name = uuid . uuid4 () return urljoin ( self . base_url , str ( name ))","title":"DavStorageProvider"},{"location":"reference/yapapi/storage/webdav/#ancestors-in-mro_1","text":"yapapi.storage.StorageProvider yapapi.storage.InputStorageProvider yapapi.storage.OutputStorageProvider abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/yapapi/storage/webdav/#class-variables_1","text":"auth","title":"Class variables"},{"location":"reference/yapapi/storage/webdav/#static-methods","text":"","title":"Static methods"},{"location":"reference/yapapi/storage/webdav/#for_directory","text":"def for_directory ( client : aiohttp . client . ClientSession , base_url : str , directory_name : str , auth : Union [ aiohttp . helpers . BasicAuth , NoneType ] = None , ** kwargs ) -> 'DavStorageProvider' View Source @classmethod async def for_directory ( cls , client : aiohttp . ClientSession , base_url : str , directory_name : str , auth : Optional [ aiohttp.BasicAuth ] = None , ** kwargs , ) -> \"DavStorageProvider\" : if base_url [ -1 ] != \"/\" : base_url += \"/\" col_url = urljoin ( base_url , directory_name ) response = await client . request ( method = \"MKCOL\" , url = col_url , auth = auth ) if response . status != 201 : response . raise_for_status () return cls ( client , col_url , auth = auth )","title":"for_directory"},{"location":"reference/yapapi/storage/webdav/#methods_1","text":"","title":"Methods"},{"location":"reference/yapapi/storage/webdav/#new_destination","text":"def new_destination ( self , destination_file : Union [ os . PathLike , NoneType ] = None ) -> yapapi . storage . Destination Creates slot for receiving file. :param destination_file: Optional hint where received data should be placed. :return: View Source async def new_destination ( self , destination_file : Optional [ PathLike ] = None ) -> Destination : upload_url = self . __new_url () return _DavDestination ( self . client , self . __export_url ( upload_url ))","title":"new_destination"},{"location":"reference/yapapi/storage/webdav/#prop_find","text":"def prop_find ( self ) View Source async def prop_find(self): headers = {\"content-type\": \"text/xml\", \"depth\": \"1\"} data = \"\"\" <?xml version=\"1.0\"?> <a:propfind xmlns:a= \"DAV:\" > <a:prop> <a:resourcetype/> <a:getcontentlength/> <a:getlastmodified/> </a:prop> </a:propfind> \"\"\" async with self.client.request( method=\"PROPFIND\", url=self.base_url, auth=self.auth, headers=headers, data=data, ) as response: if response.status != 200: response.raise_for_status() return _parse_prop_resp(await response.text())","title":"prop_find"},{"location":"reference/yapapi/storage/webdav/#upload_file","text":"def upload_file ( self , path : os . PathLike ) -> yapapi . storage . Source View Source async def upload_file ( self , path : os . PathLike ) -> Source : fp = pathlib . Path ( path ) file_size = fp . stat (). st_size async def read_file (): with io . open ( path , \"rb\" ) as f : while True : b : bytes = f . read ( _BUF_SIZE ) if not b : break yield b return await self . upload_stream ( file_size , read_file ())","title":"upload_file"},{"location":"reference/yapapi/storage/webdav/#upload_stream","text":"def upload_stream ( self , length : int , stream : AsyncIterator [ bytes ] ) -> yapapi . storage . Source View Source async def upload_stream ( self , length : int , stream : AsyncIterator [ bytes ] ) -> Source : upload_url = self . __new_url () resp = await self . client . request ( method = \"PUT\" , url = upload_url , data = stream , auth = self . auth ) _logger . debug ( \"upload done: %i\" , resp . status ) if resp . status != 201 : raise RuntimeError ( f \"invalid response for url: {upload_url}, {resp.status}/{resp.reason}\" ) return _DavSource ( self . __export_url ( upload_url ))","title":"upload_stream"}]}